package dagger.spi.model;


/**
 * Represents the different kinds of {@link Binding}s that can exist in a binding graph.
 * <p>
 * 用于表示不同的绑定类型，存在于绑定图形中
 */
public enum BindingKind {

    /**
     * A binding for an {@link javax.inject.Inject}-annotated constructor.
     * <p>
     * 表示Inject修饰的构造函数
     */
    INJECTION,

    /**
     * A binding for a {@link dagger.Provides}-annotated method.
     * <p>
     * 表示Provides修饰方法
     */
    PROVISION,

    /**
     * A binding for an {@link javax.inject.Inject}-annotated constructor that contains at least one
     * {@link dagger.assisted.Assisted}-annotated parameter.
     * <p>
     * 使用AssistedInject注解修饰
     */
    ASSISTED_INJECTION,

    /**
     * A binding for an {@link dagger.assisted.AssistedFactory}-annotated type.
     * <p>
     * 表示使用AssistedFactory修饰
     */
    ASSISTED_FACTORY,

    /**
     * An implicit binding for a {@link dagger.Component}- or {@link
     * dagger.producers.ProductionComponent}-annotated type.
     * <p>
     * component节点生成一个ProvisionBinding绑定对象
     * 的BindingKind kind属性；
     */
    COMPONENT,

    /**
     * A binding for a provision method on a component's {@linkplain dagger.Component#dependencies()
     * dependency}.
     * <p>
     * component节点不是production的
     * componentAnnotation#dependencies里面的类的无参返回类型不是void的方法
     * 生成的ProvisionBinding的BindingKind kind属性；
     */
    COMPONENT_PROVISION,

    /**
     * A binding for an instance of a component's {@linkplain dagger.Component#dependencies()
     * dependency}.
     * <p>
     * componentAnnotation#dependencies()里面
     * 的dependency节点生成ProvisionBinding绑定对象的BindingKind kind属性；
     */
    COMPONENT_DEPENDENCY,

    /**
     * A binding for a {@link dagger.MembersInjector} of a type.
     * <p>
     * 依赖类型是MembersInjector<T>
     */
    MEMBERS_INJECTOR,

    /**
     * A binding for a subcomponent creator (a {@linkplain dagger.Subcomponent.Builder builder} or
     * {@linkplain dagger.Subcomponent.Factory factory}).
     * <p>
     * （1） component中的方法返回类型是一个subcomponent.Builder（表示的是一个Builder）
     * ,并且该subcomponent不在component关联的subcomponents集合中， 那么使用当前方法
     * 和该方法所在的component类生成一个ProvisionBinding对象；
     * （2）key及其变异 匹配上component关联的module类的注解moduleAnnotation#
     * subcomponents()里面的类生成的SubcomponentDeclaration，生成ProvisionBinding对象；
     *
     * @since 2.22 (previously named {@code SUBCOMPONENT_BUILDER})
     */
    SUBCOMPONENT_CREATOR,

    /**
     * A binding for a {@link dagger.BindsInstance}-annotated builder method.
     * <p>
     * creator节点中使用BindsInstance修饰的方法（或方法参数），
     * 该方法或方法参数作为bindingElement，该方法的参数根据RequestKind剥离外壳作为
     * type生成key——生成ProvisionBinding对象的BindingKind kind属性；
     */
    BOUND_INSTANCE,

    /**
     * A binding for a {@link dagger.producers.Produces}-annotated method.
     * <p>
     * Produces修饰的方法
     */
    PRODUCTION,

    /**
     * A binding for a production method on a production component's {@linkplain
     * dagger.producers.ProductionComponent#dependencies()} dependency} that returns a {@link
     * com.google.common.util.concurrent.ListenableFuture} or {@link
     * com.google.common.util.concurrent.FluentFuture}. Methods on production component dependencies
     * that don't return a future are considered {@linkplain #COMPONENT_PROVISION component provision
     * bindings}.
     * <p>
     * component节点是production的
     * componentAnnotation#dependencies里面的节点的无参返回类型不是void的方法生成
     * ProductionBinding的BindingKind kind属性；
     */
    COMPONENT_PRODUCTION,

    /**
     * A synthetic binding for a multibound set that depends on individual multibinding {@link
     * #PROVISION} or {@link #PRODUCTION} contributions.
     * <p>
     * 如果key及其变异匹配上
     * （1）@Provides或@Produces或@Binds修饰的bindingMethod，该bindingMethod还是
     * 用了@IntoMap或@IntoSet或@ElementsIntoSet、
     * （2）@Multibinds修饰的bindingMethod方法。
     * 该key的type是Set< T>，那么生成的Binding对象的BindingKind属性；
     */
    MULTIBOUND_SET,

    /**
     * A synthetic binding for a multibound map that depends on the individual multibinding {@link
     * #PROVISION} or {@link #PRODUCTION} contributions.
     * <p>
     * 如果key及其变异匹配上
     * （1）@Provides或@Produces或@Binds修饰的bindingMethod，该bindingMethod还是
     * 用了@IntoMap或@IntoSet或@ElementsIntoSet、
     * （2）@Multibinds修饰的bindingMethod方法。
     * 该key的type是Map<K,V>，那么生成的Binding对象的BindingKind属性；
     */
    MULTIBOUND_MAP,

    /**
     * A synthetic binding for {@code Optional} of a type or a {@link javax.inject.Provider}, {@link
     * dagger.Lazy}, or {@code Provider} of {@code Lazy} of a type. Generated by a {@link
     * dagger.BindsOptionalOf} declaration.
     * <p>
     * key及其变异的type类型是Optional< T>，
     * 那么把type改成T生成新的newkey如果匹配到@BindsOptionalOf修饰的
     * bindingMethod的BindingKind kind属性；
     */
    OPTIONAL,

    /**
     * A binding for {@link dagger.Binds}-annotated method that that delegates from requests for one
     * key to another.
     * <p>
     * 被key匹配上的使用Binds修饰的bindingMethod方法生成的
     * 绑定对象的BindingKind kind属性；
     */
    // TODO(dpb,ronshapiro): This name is confusing and could use work. Not all usages of @Binds
    // bindings are simple delegations and we should have a name that better reflects that
    DELEGATE,

    /**
     * A binding for a members injection method on a component.
     * <p>
     * 生成的MembersInjectionBinding对象.
     */
    MEMBERS_INJECTION,
    ;

    /**
     * Returns {@code true} if this is a kind of multibinding (not a contribution to a multibinding,
     * but the multibinding itself).
     */
    public boolean isMultibinding() {
        switch (this) {
            case MULTIBOUND_MAP:
            case MULTIBOUND_SET:
                return true;

            default:
                return false;
        }
    }
}
