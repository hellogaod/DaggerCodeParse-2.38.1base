
Dagger的一个案例，加强对Dagger的理解

# 正常的对象创建 #

正常一个对象的引用如下，方式之一：

	//B 类
	class B{}
	
	//D 类
	class D{}

	//C类，C类构造方法传递了D实例
	class C {

		D d;
		public C(D d){
			this.d = d;
		}
	}

	//A类实例化了B,C对象
	class A {

		B b;
		C c;
		
		//方法1
		public A(B b,C c){
			this.b = b;
			this.c = c;
		}
		
		//方法2
		public A (){
			b = new B();
			c = new C(new D());
		}
	}


A类2个构造函数：方法1较方法2好处在于，如果C的构造函数参数改变，那么不需要改动A类代码。我们使用方法1实例化A对象：

	class E{
		A a = new A(new B(),new C(new D()));
	}
	

这样还是存在同样的问题，如果C或者B构造函数参数发生了改变，那么E的代码同样需要改变，有千千万万个类似于E这样的例子，即出现了控制反转思想（IOC，Inversion of Control），又叫做依赖注入（Dependency Injection，简称DI）。依赖注入这个名词好理解点：依赖某种手段，将D注入到C中，再将B,C注入到A中，确保两点：

1. 如果B，C,D构造函数参数发生变化不需要改变A和C的其他代码；

2. 依赖的手段，可以轻松完成插拔功能，例如，依赖手段实现了C类注入D，A类中注入B,C。那么如果我不需要用到A类，那么可轻松在依赖手段中消除A类（其实就是如果A类不用了，那么A类没有被实例化，并且他的B,C,D没用到的话也不会实例化）。


# 对象使用Dagger注入 #

	public class A {
		B b;
		C c;

		@Inject
		public A(B b,C c){
			this.b = b;
			this.c = c;
		}

	}

B类没有参数，直接在构造方法上使用Inject注解

	//B 类
	class B{
		@Inject
		B(){}
	}

C类因为有D参数，所以需要另外使用Module注解，在Module注解的方法上使用Provides注解，该方法传递D类实例
	
	//D 类
	class D{}

	//C类，C类构造方法传递了D实例
	class C {

		D d;
		public C(D d){
			this.d = d;
		}
	}

	@Module
	interface PrividerCModule {

		@Provides
    	@Singleton
		static C cInstance(D d){
			return new C(d);
		}
	}

D类实例的传递，以及注解的关联都会有一个核心容器，该容器使用Component注解,这里把Component容器写在HasA里面。

	class HasA {

		@Inject
		A a;

		public HasA(){
			AInstanceComponent.factory()
                .create(new D())
                .inject(this);
		}

		@Component(modules = {PrividerCModule})
		interface AInstanceComponent {
			void inject(HasA hasA);

			static Factory factory(){
				return DaggerHasA_AInstanceComponent.factory();
			}
	
			@Component.Factory
			interface Factory {
				AInstanceComponent create(@BindsInstance D d);
			}
		}

		public A getA(){
			return a;
		}
	}

这样HasA就可以使用a对象了，该对象已完成实例化。

以上就是使用Dagger实现依赖注入的Demo,相对来说比较完整的一个实例。	

# 下面来说说Dagger为我们做了什么 #

先提供两个类

	package javax.inject;

	public interface Provider<T> {
	    T get();
	}

	public interface Factory<T> extends Provider<T> {
	}

针对A类生成A_Factory类,代码较短，很好理解：

	@DaggerGenerated
	@Generated(
	    value = "dagger.internal.codegen.ComponentProcessor",
	    comments = "https://dagger.dev"
	)
	public final class A_Factory implements Factory<A>{

		private final Provider<B> bProvider;
		private final Provider<C> cProvider;
	
		
		public A_Factory(Provider<B> bProvider,
			Provider<C> cProvider){
			this.bProvider = bProvider;
			this.cProvider = cProvider;
		}

		@Override
		public A get(){
			return newInstance(bProvider.get(),cProvider.get());
		}

		public static A newInstance(B b,C c){
			return new A(b,c);
		}


		public static A_Factory create(
		Provider<B> bProvider,
		Provider<C> cProvider){
			return new A_Factory(bProvider,cProvider);
		}

	}

针对B类生成B_Factory:

	@DaggerGenerated
	@Generated(
	    value = "dagger.internal.codegen.ComponentProcessor",
	    comments = "https://dagger.dev"
	)
	public final class B_Factory implements Factory<B>{

		public B_Factory(){
		}

		@Override
		public B get(){
			return newInstance();
		}

		public static B newInstance(){
			return new B();
		}


		public static B_Factory create(){
			return new B_Factory();
		}

	}

针对	PrividerCModule类的cInstance方法生成PrividerCModule_CInstanceFactory类：

	@DaggerGenerated
	@Generated(
	    value = "dagger.internal.codegen.ComponentProcessor",
	    comments = "https://dagger.dev"
	)
	public final class PrividerCModule_CInstanceFactory implements Factory<C>{
		private final Provider<D> dProvider;

		public PrividerCModule_CInstanceFactory(Provider<D> dProvider){
			this.dProvider = dProvider;
		}

		@Override
		public C get(){
			return c(dProvider.get());
		}

		public static C c(D d){
			return PrividerCModule.cInstance(d);
		}

		public static PrividerCModule_CInstanceFactory create(Provider<D> dProvider){
			return new PrividerCModule_CInstanceFactory(dProvider);
		}
	}

写到这里需要思考一下使用@Inject注解构造函数和Module+Provider注解的区别？

> 首先如果想要在A类实例化B，那么在A类变量：`@Inject B b`;分两种情况：1.如果B是三方类，那么肯定不能再B的构造方法上加上@Inject注解；又或者B传递参数存在不确定性，这种情况下使用Modle+Provider来实例化；2.如果B可以确定固定参数，那么这种情况下可以使用@Inject修饰构造函数来实现实例化。当然了第二种情况完全可以使用第一种情况来替代，只不过较麻烦。

再来看核心容器DaggerHasA_AInstanceComponent类

	@DaggerGenerated
	@Generated(
	    value = "dagger.internal.codegen.ComponentProcessor",
	    comments = "https://dagger.dev"
	)
	final class DaggerHasA_AInstanceComponent implements HasA.AInstanceComponent{
		
		private final D d;

		private Provider<D> dProvider;
		
		private Provider<A> aProvider;

		private Provider<C> cProvider;

		private bProvider;

		private DaggerHasA_AInstanceComponent(D d){
			this.d = d;
			initialize(d);
		}

		private void initialize(final D d){
			this.dProvider = InstanceFactory.create(d);//不需要纠结InstanceFactory类，类似于Factory，只不过做了判空操作
			this.cProvider = PrividerCModule_CInstanceFactory.create(dProvider);
			this.bProvider = B_Factory.create();
			this.aProvider = A_Factory.create(bProvider,cProvider);
			
		}

		public static HasA.AInstanceComponent.Factory factory(){
			return new Factory();
		}

		private static final class Factory implements HasA.AInstanceComponent.Factory{

			@Override
			public HasA.AInstanceComponent create(D d){
				return DaggerHasA_AInstanceComponent(d);
			}
		}

		@Override
		public void inject(HasA hasA){
			injectHasA(hasA);
		}

		@CanIgnoreReturnValue
		private HasA injectHasA(HasA instance){
			HasA_MembersInjector.injectA(instance,a());
		}

		private A a(){
			return A_Factory.newInstance(b(),cProvider.get());
		}

		private B b(){
			return B_Factory.newInstance();
		}
	}

这里有一个HasA_MembersInjector类，表示如果HasA类中存在@Inject注解的变量，那么针对HasA生成HasA_MembersInjector类，该类用于赋值：

	@DaggerGenerated
	@Generated(
	    value = "dagger.internal.codegen.ComponentProcessor",
	    comments = "https://dagger.dev"
	)
	public final class HasA_MembersInjector implements MembersInjector<HasA> {
		
		public static void injectA(HasA instance,
		A a){
		instance.a = a;
		}
	}

DaggerHasA_AInstanceComponent.factory().create(new D()).inject(this);

- factory().create():用于在容器中实例化A_Factory,B_Factory等。
- inject(this):传递当前类，用于构建的A_Factory中的A实例赋值给当前类

# 总结 #

至此，一个完整的Dagger demo解说完毕。

>个人感觉理解起来应该很简单吧，起码我自己是贯通了。