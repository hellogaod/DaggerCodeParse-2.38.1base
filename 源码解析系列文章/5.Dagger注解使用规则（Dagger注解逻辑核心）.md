# 前言 #

Dagger的核心是**注解的处理**，注解的处理有两处：1.在`ProcessingStepsModule`类`processingSteps`方法收集不同类型的注解处理；2.`AndroidProcessor`中的`AndroidMapKeyValidator`和`ContributesAndroidInjectorGenerator`。

注解的处理有分为三个阶段：**校验（即使用规则）**；**生成节点对象进而相互关联成有向图**；**根据有向图生成关联代码**。

本章主要根据源码理解Dagger注解的使用规则，尽可能的全面理解。

# Dagger注解规则 #

## MapKey ##

	@Documented
	@Target(ANNOTATION_TYPE)
	@Retention(RUNTIME)
	public @interface MapKey {
	
	    boolean unwrapValue() default true;
	}


**`MapKey`注解是用于修饰注解的注解**，`@Target(ANNOTATION_TYPE)`只能修饰注解，不能用于修饰其他类型。

**校验@MapKey注解使用规则**（可自行下载并阅读源码）：

1. 被修饰的注解类必须有方法；
2. 如果MapKey.unwrapValue() = true（默认即为true）的情况下,被修饰的注解类的方法有且仅有一个，并且该方法的返回类型不可以是TypeKind.ARRAY数组类型；
3. 如果MapKey.unwrapValue() = false，被修饰的注解类方法可以有多个，方法返回类型不受限制，并且当前项目必须引用com.google.auto.value.AutoAnnotation

>com.google.auto.value:auto-value:current version

## Inject和AssistedInject ##

### Inject或AssistedInject修饰构造方法规则如下：###

1. 构造函数不允许同时使用Inject注解和AssistedInject注解；

2. 被Inject或AssistedInject修饰的构造函数不允许使用private修饰；

3. 被Inject或AssistedInject修饰的构造函数不能被Qualifier修饰过的注解修饰
4. 被Inject或AssistedInject修饰的构造函数不能被使用Scope注解修饰的注解修饰

5. 被Inject或AssistedInject修饰的构造函数里面的参数（作为依赖）规则：
 
 - 参数不能是Produced或Producer类型；

 - 参数作为依赖，对依赖校验，请看下面的**依赖校验规则**

6. 被Inject或AssistedInject修饰的构造函数如果继承异常，那么异常一定要继承RuntimeException或Error，否则报错

7. 使用了Inject或AssistedInject修饰的元素所在类不可以被private类使用（可能是警告，这种情况不被支持）

8. 使用了Inject或AssistedInject修饰的构造函数所在类不能是Abstract抽象类，否则报错；

9. 如果使用Inject或AssistedInject修饰的构造函数所在类是一个内部类，那么必须使用Static修饰；

10. 一个类最多只能有一个构造函数被Inject或AssitedInject修饰；

11. 使用AssistedInject修饰的构造函数所在类，该类不能被使用Scope注解修饰的注解修饰

12. 使用Inject修饰的构造函数所在类，该类最多只能有一个使用Scope注解修饰的注解修饰；

### Inject或AssistedInject修饰变量和普通方法 ###

**Inject或AssistedInject修饰变量和普通方法，实际校验的是变量和普通方法所在类**，规则如下：

1. 校验该类中所有被Inject修饰的变量，规则如下，

 - 不能被final修饰；
 
 - 不要被private修饰（这里可能是警告，private修饰变量不被支持）；

 - 不要被Static修饰（可能是警告，static修饰变量不被支持）；

 - 变量作为依赖进行校验：①变量不能是Produced或Producer类型；②变量作为依赖，对依赖校验，请看下面的**依赖校验规则**；

2. 校验该类中所有被Inject修饰的方法，规则如下，

 - 方法不能被abstract修饰；
 
 - 不要被private修饰（这里可能是警告，private修饰变量不被支持）；
 
 - 不要被Static修饰（可能是警告，static修饰变量不被支持）；

 - 使用Inject修饰的方法不能存在泛型类型;

 - 使用Inject修饰的方法不能在方法上实现抛异常功能

 - 方法上的参数作为依赖，需要做依赖校验:①参数不能是Produced或Producer类型；②参数作为依赖，对依赖校验，请看下面的**依赖校验规则**；

3. 使用了Inject修饰的类所在类型不可以被private类使用（可能是警告，这种情况不被支持）

4. Inject注解不能在Kotlin文件中使用

5. 如果Inject或AssitedInject修饰的类存在非Object父类，对父类重复1往下校验；并且如果父类构造函数使用了Inject或AssitedInject修饰，那么对该构造函数根据以上构造函数校验方法校验

## AssistedInject，AssistedFactory和Assisted ##

### AssistedInject ###

1. AssistedInject校验规则以上和Inject已经在一起有所描述，下面是追加

2. **AssistedInject必须修饰的是构造函数**；

### Assisted ###

Assisted规则如下：

1. @Assisted只能修饰方法参数,并且必须满足下面三个条件之一

 - @Assisted修饰的参数，位于一个被@AssistedInject修饰的构造函数中（下面有具体的补充）；

 - @Assisted修饰的参数所在的方法是所在类中唯一的一个abstract、非static、非private修饰，并且该方法所在类使用了@AssistedFactory注解修饰

 - @Assisted修饰的参数所在的方法 ，该方法命名包含"copy" ，该方法所在类是一个data类型的kotlin文件

2. @Assisted修饰的参数 不能被Qualifier注解修饰的注解修饰

**补充**：@AssistedInject修饰的构造函数使用了 @Assisted修饰的参数规则：

 - @AssistedInject修饰的构造函数中不允许出现重复的@Assisted修饰的参数，例如C （@Assited A a,Assited A b）,因为a和b类型都是A并且使用的@Assisted的参数都一样，所以会报错

>这样两种情况都不会报错：
>1. C （@Assited B a,Assited A b）;
>2. C （@Assited("x") A a,Assited A b）


### AssistedFactory ###

AssistedFactory使用规则如下：

1. 使用AssistedFactory修饰的类型仅仅支持抽象类或接口；

2. 如果AssistedFactory修饰的元素是内部类，那么必须使用static修饰；

3. AssistedFactory修饰的元素必须有且仅有一个abstract（*接口不需要*）、非static、非private修饰的方法；

4. AssistedFactory修饰的元素包含abstract（*接口不需要*）、非static、非private的方法的返回类型的构造函数必须使用AssistdInject修饰

5. AssistedFactory修饰的元素，该类中的abstract（*接口不需要*）、非static、非private的方法不能存在泛型

6. @AssistedFactory修饰的元素里面的唯一方法的返回类型的构造函数中使用@Assisted修饰的参数和该方法的参数类型一致。


## 方法绑定规则 ##

### 方法绑定类型 ###

方法绑定类型收集于`BindingMethodValidatorsModule`

	@Module
	public interface BindingMethodValidatorsModule {
	
	    //下面的都是该方法参数
	    @Provides
	    static ImmutableMap<ClassName, BindingMethodValidator> indexValidators(
	            Set<BindingMethodValidator> validators) {
	        return uniqueIndex(validators, BindingMethodValidator::methodAnnotation);
	    }
	
	    @Binds
	    @IntoSet
	    BindingMethodValidator provides(ProvidesMethodValidator validator);
	
	    @Binds
	    @IntoSet
	    BindingMethodValidator produces(ProducesMethodValidator validator);
	
	    @Binds
	    @IntoSet
	    BindingMethodValidator binds(BindsMethodValidator validator);
	
	    @Binds
	    @IntoSet
	    BindingMethodValidator multibinds(MultibindsMethodValidator validator);
	
	    @Binds
	    @IntoSet
	    BindingMethodValidator bindsOptionalOf(BindsOptionalOfMethodValidator validator);
	}

如上代码，第一个方法表示收集绑定方法校验类型，下面五个方法表示不同类型的绑定方法，所以**方法绑定有五种类型**，我们来看：

1. @Module或@ProducerModule修饰的父类中使用@Provides修饰的方法；

2. @ProducerModule修饰的父类中使用@Produces修饰的方法；

3. @Module或@ProducerModule修饰的父类中使用@Binds修饰的方法；

4. @Module或@ProducerModule修饰的父类中使用@Multibinds修饰的方法;

5.@Module或@ProducerModule修饰的父类中使用@BindsOptionalOf修饰的方法； 

### 方法绑定规则 ###

在`BindingMethodProcessingStep`中完成校验工作

> 对方法的五种绑定类型进行校验，@Provides、@Produces、@Binds、@Multibinds、@BindsOptionalOf。

**校验规则如下：**

1.方法只允许使用五种绑定类型中的一种，否则报错；

2.①@Provides修饰的方法

 - 完全满足**绑定方法校验规则**；
  
 - 检查方法参数不是Producer或Producer类型

2.② @Produces修饰的方法

 - 基本满足**绑定方法校验规则**，但是又局部修改的地方，以下面描述为主
 
 - 该绑定方法节点不允许使用了Nullable注解；
 
 -  如果方法的返回类型是ListenableFuture类型，那么必须是ListenableFuture<T>形式，否则报错；

 - 如果方法的返回类型是ListenableFuture<T>,那么对**绑定节点校验规则**进行修改：对1.a.(3)改：***绑定节点类型：绑定方法返回类型是ListenableFuture< T >***,那么T只能是原始类型或数组或类型变量或类或接口；对1.c修改：如果使用了ElementsIntoSet注解修饰，***绑定节点类型:绑定方法返回类型是ListenableFuture< T >***,那么T只能是Set<V>格式，并且V只能是原始类型或数组或类型变量或类或接口

2.③ @Binds修饰的方法

 - 基本满足下面的**绑定方法校验规则**，有追加的地方
 
 - 追加：方法参数有且仅有一个；

 - 追加：如果使用@Binds和@ElementsIntoSet修饰了方法，那么方法的返回类型必须是Set<T>，并且方法参数T；

 - 追加：方法参数必须可以分配给方法返回类型，例如①Set<T>表示方法返回类型，T则表示方法参数；②A extends B，方法返回类型是B，A可以是方法参数。

2.④ @Multibinds修饰的方法

 - 基本满足下面的**绑定方法校验规则**
 
- 该绑定方法参数必须为空，所以不存在参数依赖校验

 - 对**绑定节点规则**1.a.(3)和1.b改：***绑定节点类型：方法返回类型***必须是Map<K, V> or Set<T>，并且V和T不能是FrameworkType类型（FrameworkType：Provider, Lazy, MembersInjector,Produced, Producer）

2.⑤ @BindsOptionalOf修饰的方法

 - 基本满足下面的**绑定方法校验规则**

 - 对**绑定节点规则**1.a.(3)和1.b追加：如果方法返回类型的构造方法使用了Inject注解修饰，那么要么当前方法使用了Qualifier注解修饰的注解修饰了；要么该方法返回类型满足以下一个条件即可：①不是类；②使用abstract修饰；③存在泛型，而且泛型类型不是类或接口

 - @BindsOptionalOf修饰的方法参数必须为空


### IntoMap，IntoSet或ElementsIntoSet 多重绑定 ###

使用IntoMap，IntoSet或ElementsIntoSet注解规则：

1. 修饰的是方法；

2. IntoMap，IntoSet或ElementsIntoSet注解在同一个绑定方法上只能使用其中的一个

3. IntoMap，IntoSet或ElementsIntoSet注解必须和@Provides（或@Produces或 @Binds）一起使用。

>使用IntoMap，IntoSet或ElementsIntoSet注解修饰的方法，表示**多重绑定**（字面翻译的，这么理解没错），Multibinds绑定我们称为**Multibinds绑定**，以示区别。这个只是自己对他们的区分，不代表官方哈

**那么IntoMap，IntoSet或ElementsIntoSet 和 Multibinds区别在哪里？？？**

>没啥区别吧，只不过IntoMap，IntoSet或ElementsIntoSet 和 Multibinds不能同时使用，逻辑上的区别请往下看他们的用法，个人目前的理解，只不过是写法上的区别，某种程度上两种形式可以相互替换。

## BindsInstance ##

BindsInstance注解使用规则如下：

1. BindsInstance注解仅仅可以用来修饰方法和方法参数；

2. BindsInstance注解修饰方法参数的校验

 - 方法参数校验继承**节点校验规则**，并且**绑定节点类型当前表示参数类型**，自行查看；

 - @BindsInstance修饰的参数所在方法必须使用abstract修饰，（进过校验确定，如果是接口里面的一般方法也可）

 - @BindsInstance修饰的参数所在方法的返回类型，只能是一个类或接口（可以是泛型），不能是void、数组又或者原始类型

3.  BindsInstance注解修饰方法的校验；

 - 方法校验继承**节点校验规则**，并且**绑定节点类型当前表示方法参数类型**，自行查看；

 - @BindsInstance修饰的方法必须使用abstract修饰（进过校验确定，如果是接口里面的一般方法也可）

 - @BindsInstance修饰的方法 有且仅有一个参数；

 - @BindsInstance修饰的方法 所在的父类不允许使用Module或ProducerModule修饰

 - @BindsInstance修饰的方法 方法所在父类不允许使用(Producer)Component 或 (Producer)Subcomponent注解修饰

## Module和ProducerModule ##

module类使用Module和ProducerModule注解规则如下：

1. 如果在Kotlin Companion Object对象中使用则无效；

2. module类的所有方法使用@Provides、@Produces、@Binds、@Multibinds、@BindsOptionalOf注解修饰，那么就表示绑定方法，具体规则上面已经做了介绍，这里不再赘述

3. module类中不允许既使用abstract抽象方法又使用非静态的普通方法；

4. module类不允许使用private修饰；并且不允许放在一个private私有类型中；

5. module类不允许是匿名类；

6. 如果module类所在父类型是public，那么module类使用的Module注解的include包含的子module类，如果子module类所在父类型非public同时遍历子module类中的方法，有非static和非abstract修饰的方法，则报错；

7. 同一个module类中不允许出现两个同名的绑定方法；

8. 如果module类不是接口，校验module类是否存在继承：绑定方法既不允许被继承，方法也不允许被继承后实现绑定

9. 如果module类使用了泛型，那么该module类必须使用abstract修饰；

10. (Producer)Module#includes里面的module类进行校验

 - (Producer)Module#includes里面的module类只能是类或接口，并且不允许使用泛型

 - Module#includes里面的module类只能使用Module注解，ProductionModule#includes里面的module类既可以Module也可以使用ProductionModule注解

 - (Producer)Module#includes里面的module类不允许是Companion Object对象（kotlin文件的一个类型）

11. Module#subcomponents里面的component类进行校验

 - component类只能是类或接口

 - 只能使用(Production)Subcomponent注解修饰，并且该subcomponent类必须存在被(Production)Subcomponent.Builder(或Factory)注解修饰的内部类

12. module类不允许使用Scope注解修饰的注解修饰；

13. 当前module类的Module#includes不能包含自己

14. 如果module类存在 Kotlin Companion Object对象

 - Companion Object对象里面不存在Overrider重写方法，否则报错；

 - Module中的Companion Object对象如何存在绑定方法，该绑定方法不允许private私有；

## Component，ProductionComponent，Subcomponent，ProductionSubcomponent，Component.Builder,Component.Factory,Subcomponent.Builder,Subcomponent.Factory，ProductionComponent.Builder,ProductionComponent.Factory,ProductionSubcomponent.Builder,ProductionSubcomponent.Factory ##

###校验使用(Production)(Sub)Component注解的component类###

规则如下：

1. (Producer)Module,(Production)(Sub)Component注解最多在节点上只能出现其中一个；

2. 如果当前component类使用了@CancellationPolicy注解，那么只能被Production(Sub)Component修饰；

3. component类只能是这两种情况：要么是接口，要么是抽象类

4. 校验component类中的creator(使用(Production)(Sub)Component.Builder或(Production)(Sub)Component.Factory注解)

 - 自行查看下面(Production)(Sub)Component.Builder或(Production)(Sub)Component.Factory注解规则;

 - component类中的内部类最多只能有一个使用(Production)(Sub)Component.Builder或(Production)(Sub)ComponentFactory的注解;

5. @Reusable不允许被使用在component类上

6. 校验component类上的方法

 - 如果component是kotlin文件，那么该方法不允许使用java关键字命名

 - 对component类的非private、非static、abstract修饰的方法校验，请看下面的**component类方法校验规则**：

7. ①对入口方法的校验：该方法不允许被重写，并且方法参数为空，返回类型不能是void，方法使用abstract修饰（如果是接口方法，则不需要），②入口方法有且仅有一个；

8. 方法返回类型 使用(Production)SubComponent注解 和 方法返回类型 使用component类的Builder或Factory注解 只能出现一个；

9. component#dependencies校验：里面的类不能使用(Producer)Module注解；

10. (Producer)Module#includes校验,自行去查看

###(Production)(Sub)Component注解的component类里面的方法校验###
component类里面的方法校验如下：

1. 方法不允许使用泛型类型

2. 如果方法返回的类型使用了(Production)SubComponent注解

 - ①该方法参数类型必须使用(Producer)Module注解，并且只能出现一次Module注解或ProducerModule注解，（换句话理解就是该参数类型有且仅有一个，并且必须使用(Producer)Module注解）

 - 该方法参数类型使用的(Producer)Module注解，一定能被关联上（意思就是这个参数类型需要在(Production)(Sub)Component#module或Module#includes出现过，表示当前参数类型的可达性）

3. 如果方法返回类型使用了(Production)(Sub)Component.Builder或(Production)(Sub)Component.Factory注解

 - 方法参数必须为空

 - 当前方法的返回类型作为**(Production)(Sub)Component.Builder或(Production)(Sub)Component.Factory注解校验**，规则在其正下方，自行查看

4. 如果component类中的方法返回类型既不是使用(Production)SubComponent注解，又不是使用(Production)(Sub)Component.Builder或(Production)(Sub)Component.Factory注解

 - ①如果方法无参，对当前方法的节点和方法返回类型进行依赖校验，详细请查看**依赖校验规则**

 - ②如果方法有且仅有一个参数，方法返回类型要么是void，要么返回类型和方法参数类型一致；并且将方法和方法参数作为成员注入类型进行**成员注入方法校验规则**，自行下去查看

 - ③方法不得超过一个参数

###校验使用(Production)(Sub)Component.Builder或(Production)(Sub)Component.Factory注解###

规则如下：

1. 节点上最多只能使用一个Builder或Factory注解；

2. 该节点所在父类一定使用了(Production)(Sub)Component注解；

3. 该节点只能是接口或类，如果是类那么只能存在一个默认无参构造函数（即使用者，不能自己添加构造函数）；

4. 节点不能使用泛型，不能使用private修饰，必须使用Static修饰（但是不是Static修饰好像也没问题），必须使用abstract修饰（如果是接口，非abstract修饰好像也没问题）；

5. 对Factory和Builder注解进行分别校验：

 - Factory校验：①非private，非static，abstract修饰（接口可以避免abstract修饰）的方法有且仅有一个；②该方法不允许使用泛型类型；③该方法返回类型必须是component类或component子类（最好是component类，否则报警告）；④该方法不能使用@BindsInstance注解修饰；⑤方法参数不能是原始类型并且必须使用@BindsInstance修饰

 - Builder校验：
 - ①校验如果是kotlin文件，则不允许使用java关键字作为方法名；
 - ②该节点里面的方法参数最多只能有一个，
 - 1)方法无参：a.方法返回类型必须是component类或其子类(如果是component子类会报警告)，b.方法不能使用@BindsInstance注解修饰,
 - 2)方法有且仅有一个参数，返回类型必须是component类或其子类，该方法和方法参数不能同时使用@BindsInstance注解修饰，并且方法或方法参数被@BindsInstance注解修饰，那么方法参数不能是原始类型；
 - ③该节点的方法只能是非private、非static、abstract修饰(接口没有abstract修饰这条规定)，并且方法不允许使用泛型；

> Builder和Factory注解使用存着区别，Factory修饰的节点里面的方法必须是参数使用@BindsInstance修饰，而且可以有多个参数；
> Builder修饰的节点方法和参数上都可以使用@BindsInstance修饰，只不过不能同时出现，并且参数最多有一个。

## AndroidInjectionKey和ClassKey ##

AndroidInjectionKey和ClassKey 注解修饰方法使用规则如下：

1. AndroidInjectionKey和ClassKey只能修饰方法；

2. 如果该方法同时使用了Qualifier修饰的注解修饰，那么下面的不需要继续校验了；

3. 该方法返回类型如果不是AndroidInjector.Factory及其子类，不需要继续校验了，该方法直接被忽略；

4. 如果该方法使用了Scope注解修饰的注解修饰，该方法必须使用@SuppressWarnings注解修饰，并且该@SuppressWarning注解包含dagger.android.ScopedInjectorFactory值（意思就是最好别使用Scope修饰的注解修饰）；

5. 该方法的返回类型必须是AndroidInjector.Factory<T>，否则报错

6. 如果该方法还使用了Binds注解，并且方法参数只有一个：（对照下面的案例理解），该方法参数类型`UserFragmentSubcomponent.Factory`必须可以匹配上`AndroidInjector.Factory<ClassKey的value值：UserFragment>`

例如：

	@Binds
	@IntoMap
	@ClassKey(UserFragment.class)
	abstract AndroidInjector.Factory<?> bindAndroidInjectorFactory(
	  UserFragmentSubcomponent.Factory builder);
	
	@Subcomponent
	public interface UserFragmentSubcomponent extends AndroidInjector<UserFragment> {
	@Subcomponent.Factory
	interface Factory extends AndroidInjector.Factory<UserFragment> {}
	}

## ContributesAndroidInjector ##

ContributesAndroidInjector注解修饰的方法使用规则如下：

1. @ContributesAndroidInjector修饰的是必须方法，并且该方法必须使用abstact修饰；

2. 该方法参数不能为空；

3. 该方法所在父类必须使用Module注解修饰；

4. 该方法的返回类型不能使用泛型；

5. ContributesAndroidInjector#modules里面的类必须使用@Module注解

6. 该方法不能使用Qualifier修饰的注解修饰

## Qualifier ##

	@Target({ElementType.ANNOTATION_TYPE})
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	public @interface Qualifier {
	}

修饰注解的注解，规则如下：

1. 被Inject或AssistedInject修饰的构造函数不能被Qualifier修饰过的注解修饰

2. 被Qulifiers注解修饰的注解在某个节点上的使用最多只能存在一个

3. @Assisted修饰的参数,该参数节点不能被Qualifier注解修饰的注解修饰

4. Qualifier修饰的注解不能和@ContributesAndroidInjector同时使用

## Scope ##

	@Target(ANNOTATION_TYPE)
	@Retention(RUNTIME)
	@Documented
	public @interface Scope {}

修饰注解的注解，规则如下：

1. 被Inject或AssistedInject修饰的构造函数不能被使用Scope注解修饰的注解修饰;

2. 被Scope注解修饰的注解在某个节点上的使用最多只能存在一个;

3. AssistedInject修饰的构造函数所在类，该类不能被使用Scope注解修饰的注解修饰;


## 绑定的节点校验规则 ##

被绑定的节点校验规则如下：

1. 判断当前element节点，是否使用了IntoMap，IntoSet或ElementsIntoSet注解

 - a. 如果都没有，（1）***绑定节点类型***不允许使用FrameworkType中的类型（FrameworkType：Provider, Lazy, MembersInjector,Produced, Producer） ;(2)如果当前节点没有使用Qulifier修饰的注解修饰并且***绑定节点类型***是以类或接口形式存在，那么***绑定节点类型***不允许使用AssistdInject修饰也不允许使用AssistedFactory注解修饰；（3）***绑定节点类型***只能是原始类型或数组或类型变量或类或接口；

 - b. 如果使用了IntoMap 或 IntoSet注解，***绑定节点类型***只能是原始类型或数组或类型变量或类或接口

 - c. 如果使用了ElementsIntoSet注解修饰，***绑定节点类型***只能是Set<T>格式，并且T只能是原始类型或数组或类型变量或类或接口

2. 绑定节点上使用Qualifier注解修饰的注解最多只能有一个；

3. 检查节点上存在使用@MapKey修饰的注解

 - 如果***不允许使用多重绑定***：不继续当前@MapKey继续往下判断

 - ***允许使用多重绑定的情况下***：@IntoMap和@MapKey注解修饰的注解一定是同时存在于绑定节点上的，并且@MapKey修饰的注解有且仅有一个。

4. 节点多重绑定校验

 - ***不允许使用多重绑定***：那么节点上一定不能出现IntoMap，IntoSet或ElementsIntoSet注解

 - ***允许使用多重绑定***：那么IntoMap，IntoSet或ElementsIntoSet注解有且仅有一个；

 - 如果节点有使用了@Providers注解，@Provides.type不能与IntoMap，IntoSet或ElementsIntoSet注解一起使用（说实话，我没遇到过，反正别这么用就对了）

5. 节点上 所有使用Scope注解修饰的注解

 - 如果***允许使用Scope注解修饰的注解***：那么最多只能存在一个 

 - 如果***不允许使用Scope注解修饰的注解***：则不可使用


>a.***绑定节点类型*** 是什么来源于继承者，请对照其继承者查看

>b.***是否允许使用多重绑定***，由继承者决定，请对照继承者查看

>c.***是否允许使用Scope注解修饰的注解***，由继承者决定，请对照继承者查看


## 绑定方法校验规则 ##


这里决定了绑定节点的一些疑问：

>a.***绑定节点类型*** 是什么来源于继承者，请对照其继承者查看

**答：绑定节点类型，这里表示方法的返回类型**


**绑定方法校验规则，继承了绑定节点校验规则**

**完全继承绑定节点校验规则**，并且还有自己的一套如下规则：

1. 校验绑定方法所在父类（如果父类是Component Object类型的kotlin文件，那么获取父类的父类）节点：

 - 如果绑定方法使用的注解使用@Provides修饰，那么父类一定使用@Module或@ProducerModule修饰；

 - 如果绑定方法使用的注解使用@Produces修饰，那么父类一定使用@ProducerModule修饰；

 - 如果绑定方法使用的注解使用@Binds修饰，那么父类一定使用@Module或@ProducerModule修饰；

 - 如果绑定方法使用的注解使用@Multibinds修饰，那么父类一定使用@Module或@ProducerModule修饰；

 - 如果绑定方法使用的注解使用@BindsOptionalOf修饰，那么父类一定使用@Module或@ProducerModule修饰；

2. 绑定方法不允许使用泛型；

3. 绑定方法不允许使用private修饰；

4. 检验抽象修饰，根据是否***必须或必须不使用abstract修饰***判断

 - 如果必须使用Abstract，那么必须使用；如果必须具体方法，那么绝对不能使用abstract抽象方法

5. ***方法上支持继承哪些异常***

6. 对方法依赖参数进行校验，请参考**依赖检验规则**

 
> ***必须或必须不使用abstract修饰***：由继承者决定，请对照继承者查看

> ***方法上支持继承哪些异常***：由继承者决定，请对照继承者查看

**继承者决定参数如下**

1.Provides绑定

 >①必须使用实体类，非abstract
 >②方法可以继承RuntimeException和Error异常
 >③允许多重绑定
 >④允许使用Scope注解修饰的注解修饰

2.Produces绑定

 >①必须使用实体类，非abstract
 >②方法可以继承Exception和Error异常
 >③允许多重绑定
 >④不允许使用Scope注解修饰的注解修饰

3.Binds绑定

 >①必须使用abstract
 >②方法不允许继承异常
 >③允许多重绑定
 >④允许使用Scope注解修饰的注解修饰

4.Multibinds绑定

 >①必须使用abstract
 >②方法不允许继承异常
 >③不允许多重绑定
 >④不允许使用Scope注解修饰的注解修饰

5.BindsOptionalOf绑定

 >①必须使用abstract
 >②方法不允许继承异常
 >③不允许多重绑定
 >④不允许使用Scope注解修饰的注解修饰

## 依赖校验规则 ##

如果依赖节点使用了Assisted注解，不需要继续下面的依赖校验，具体校验如下 :

1. 如果依赖节点是Kotlin文件，缺少有关其限定符的元数据，则出错;

2. 依赖节点使用Qulifiers注解修饰的注解最多只能使用1个；

3. 在没有使用Qulifiers注解修饰的注解修饰该依赖并且该依赖是类或接口情况下，该`真实节点`（看下面的注释①）满足一下条件；
 
 - `真实节点`构造函数不能使用AssistdInject修饰修饰；
 
 - 节点只有是T或Provider< T>情况下才可以使用AssistedFactory注解修饰

4. `真实节点`不能是通配符，也就是说T必须是实际类型

5. 如果`真实节点`T是MembersInject<V>，则表示成员，使用如下的**成员注入请求校验规则**，自行下去查看

> 注释①，真实节点：根据请求类型RequestKind，获取里面的真正的节点，例如T，Lazy<T>,Provider<T>, Producer<T>,Produced<T>,真正的节点都是T

## 成员校验规则 ##

### 成员注入请求校验规则 ###

MembersInjector<T>(MembersInjector<T>，表示成员注入)的T(T，表示成员类型)进行校验，规则如下：

1. 成员注入MembersInjector<T>不能使用Qualifier注解修饰的注解修饰；

2. 成员类型T只能是类或接口；

3. 如果成员节点T不是泛型，那么它的类型也一定不是泛型，例如成员节点是List，但是实际上List<T>才是正常的表现形式，那么就会报错；

4. 如果成员节点T是泛型，那么该泛型只能是类或接口或数组（数组成员只能是类或接口或原始类型或数组），例如T是T<V>,那么V必须只能是类或接口或数组，数组成员只能是类或接口或原始类型或数组；

### 成员注入方法校验规则 ###

对方法和方法参数（成员注入类型）校验，规则如下：

1. 该方法参数有且仅有一个；

2. 方法和方法参数都不能使用Qualifier注解修饰的注解修饰；

3. 方法参数作为成员注入类型，只能是类或接口

 - 不允许原始类型（例如List<T>表示节点类型,List则表示原始类型）;
 
 - 如果使用泛型，那么节点里面的泛型，只能是类或接口或数组，数组又只能是类或接口或原始类型或数组;

# 结束 #

大体上的注解使用规则应该都说明，但是不一定是全部，可能会有补充，例如有向图的规则或者其他。

这就结束啦？不，这仅仅是个开始，这里只是描述了注解的用法，还有具体的逻辑实现才是核心中的核心。

以上的描述其实也大体上体现了dagger校验的框架结构。

当前源码所在版本：**v0.4**