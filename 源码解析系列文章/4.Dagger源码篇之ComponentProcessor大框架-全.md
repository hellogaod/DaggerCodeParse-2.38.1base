# 前言 #

源码解析过程中很多时候出现迷失方向的问题，突然不知所措，我是谁，我在干啥的念头涌出。回头想想：哦~我好像是在看Dagger源码，Dagger是干啥的

 > 人生方向上也会出现类似事件，而且灰常灰常多，最终迷失自我，迷失目标。所以一时之勇简单，坚持才是最难得的，尤其当下大环境下。

## 源码解读感言 ##

代码是自己一点一滴去解析的，而且并没有教科书式的和设计思想（可能改代码本身就是一个DI或IOC思想）结合讲解，最终会花一个篇幅去介绍本源码相关模式和设计思想。

随着不断解析，发现越来越简单，当然代码里我认为重要的会有注释，又或者说当前的源码解析并没有到位（也就是别人或者过段时间的自己可能看不懂），完全有可能存在这种情况，但是我相信如何真的认真按照当前的文章去看，肯定有收获

>**至回头看的自己**：自己的锅还得自己扛，哈哈哈


# 生成类的命名规则 #

1.ProcessorComponent生成DaggerComponentProcessor_ProcessorComponent

 > ProcessorComponent是ComponentProcessor的内部类

生成规则源码如下：

	public final class ComponentNames {
	  /** Returns the class name for the root component. */
	  public static ClassName getRootComponentClassName(ComponentDescriptor componentDescriptor) {
	    checkState(!componentDescriptor.isSubcomponent());
	    ClassName componentName = ClassName.get(componentDescriptor.typeElement());
	    return ClassName.get(componentName.packageName(), "Dagger" + classFileName(componentName));
	  }
	...
	}

解析：1.位于当前Component所在包下；2.生成的类名有一个前缀Dagger，并且后缀`className.simpleNames()`（当前类及其父类，从父类到当前类有序排列），以"_"分隔

2.ProcessingEnvironmentModule类中的daggerElements方法会生成ProcessingEnvironmentModule_DaggerElementsFactory类

> 其实就是一个把module类和方法首字母大写然后使用"_"分隔，在后缀"Factory"

生成源码规则在SourceFiles类中，如下：

	public static ClassName generatedClassNameForBinding(Binding binding) {
	switch (binding.bindingType()) {
	  case PROVISION:
	  case PRODUCTION:
	    ContributionBinding contribution = (ContributionBinding) binding;
	    switch (contribution.kind()) {
	      case ASSISTED_INJECTION:
	      case INJECTION:
	      case PROVISION:
	      case PRODUCTION:
	        return elementBasedClassName(
	            MoreElements.asExecutable(binding.bindingElement().get()), "Factory");
	
	      ...
	    }
		...
	}
	throw new AssertionError();
	}


# 难点：ComponentProecesorStep关联和代码梳理#

**这也是Dagger核心的核心**

先来一个关联图，将之间的关系串联起来：

![请添加图片描述](https://img-blog.csdnimg.cn/f15a34b672cc4d5caa1e3f951c0c85d9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5L2b5a2m5b6SLeS7o-eggeaQrOi_kOW3pQ==,size_20,color_FFFFFF,t_70,g_se,x_16)

> 看不清在浏览器浏览大图，该图非常重要


### ComponentProcessingStep构造函数 ###

	    @Inject
	    ComponentProcessingStep(
	            XMessager messager,
	            ComponentValidator componentValidator,
	            ComponentCreatorValidator creatorValidator,
	            ComponentDescriptorValidator componentDescriptorValidator,
	            ComponentDescriptorFactory componentDescriptorFactory,
	            BindingGraphFactory bindingGraphFactory,
	            SourceFileGenerator<BindingGraph> componentGenerator,
	            BindingGraphValidator bindingGraphValidator)

其他参数不表，主要看`componentGenerator`

### componentGenerator由ComponentGeneratorModule提供 ###

>该module方法引入了一个TopLevelImplementationComponent的subcomponent类，主要作用是给当前ComponentGenerator类提供参数

	@Module(subcomponents = TopLevelImplementationComponent.class)
	public interface ComponentGeneratorModule {
	
	    @Binds
	    abstract SourceFileGenerator<BindingGraph> componentGenerator(ComponentGenerator generator);
	}

### ComponentGenerator类 ###

>该类中处理Component注解的相关代码生成，但是我们可以发现，这里的代码非常至少，核心还是调用`ComponentImplementation`的`generate`方法，当我们点开该方法会发现一脸懵逼，里面的那么些参数哪里来的？？？

	@Inject
    ComponentGenerator(
            XFiler filer,
            DaggerElements elements,
            SourceVersion sourceVersion,
            TopLevelImplementationComponent.Factory topLevelImplementationComponentFactory
    )

  该构造函数我们只看`TopLevelImplementationComponent.Factory`，Component注解逻辑代码：

	@Override
    public ImmutableList<TypeSpec.Builder> topLevelTypes(BindingGraph bindingGraph) {
      ComponentImplementation componentImplementation =
        topLevelImplementationComponentFactory
            .create(bindingGraph)
            .currentImplementationSubcomponentBuilder()
            .bindingGraph(bindingGraph)
            .parentImplementation(Optional.empty())
            .parentRequestRepresentations(Optional.empty())
            .parentRequirementExpressions(Optional.empty())
            .build()
            .componentImplementation();
      verify(
        componentImplementation
            .name()
            .equals(getRootComponentClassName(bindingGraph.componentDescriptor())));
      return ImmutableList.of(componentImplementation.generate().toBuilder());
    }

该方法componentImplementation的生成注入了我们需要的参数,针对如下代码解析

	topLevelImplementationComponentFactory
            .create(bindingGraph)
            .currentImplementationSubcomponentBuilder()
            .bindingGraph(bindingGraph)
            .parentImplementation(Optional.empty())
            .parentRequestRepresentations(Optional.empty())
            .parentRequirementExpressions(Optional.empty())
            .build()
            .componentImplementation();

1.`topLevelImplementationComponentFactory.create(bindingGraph).currentImplementationSubcomponentBuilder()`

如下图所示，实际是实例化CurrentImplementationSubcomponent.Builder

	@PerGeneratedFile
	@Subcomponent
	// This only needs to be public because the type is referenced by generated component.
	public interface TopLevelImplementationComponent {
	    CurrentImplementationSubcomponent.Builder currentImplementationSubcomponentBuilder();
	
	    /** Returns the builder for {@link TopLevelImplementationComponent}. */
	    @Subcomponent.Factory
	    interface Factory {
	        TopLevelImplementationComponent create(@BindsInstance @TopLevel BindingGraph bindingGraph);
	    }
	}

2.`xxx.bindingGraph(bindingGraph).parentImplementation(Optional.empty()).parentRequestRepresentations(Optional.empty()).parentRequirementExpressions(Optional.empty()).build()`,传递参数，这里实际就传递了bindingGraph，其他的都是空，这些参数为实例化`ComponentImplementation`对象做准备，如下图所示还提供了`ChildComponentImplementationFactoryModule`的`provideChildComponentImplementationFactory`方法，该方法目的也是为了实例化`ComponentImplementation`对象做准备

	@Subcomponent(
	        modules = CurrentImplementationSubcomponent.ChildComponentImplementationFactoryModule.class)
	@PerComponentImplementation
	// This only needs to be public because the type is referenced by generated component.
	public interface CurrentImplementationSubcomponent {
	    ComponentImplementation componentImplementation();
	
	    /**
	     * A module to bind the {@link ComponentImplementation.ChildComponentImplementationFactory}.
	     */
	    @Module
	    interface ChildComponentImplementationFactoryModule {
	        @Provides
	        static ComponentImplementation.ChildComponentImplementationFactory provideChildComponentImplementationFactory(
	                CurrentImplementationSubcomponent.Builder currentImplementationSubcomponentBuilder,
	                Provider<ComponentImplementation> componentImplementatation,
	                Provider<ComponentRequestRepresentations> componentRequestRepresentations,
	                Provider<ComponentRequirementExpressions> componentRequirementExpressions) {
	            return childGraph ->
	                    currentImplementationSubcomponentBuilder
	                            .bindingGraph(childGraph)
	                            .parentImplementation(Optional.of(componentImplementatation.get()))
	                            .parentRequestRepresentations(Optional.of(componentRequestRepresentations.get()))
	                            .parentRequirementExpressions(Optional.of(componentRequirementExpressions.get()))
	                            .build()
	                            .componentImplementation();
	        }
	    }
	
	    /**
	     * Returns the builder for {@link CurrentImplementationSubcomponent}.
	     */
	    @Subcomponent.Builder
	    interface Builder {
	        @BindsInstance
	        Builder bindingGraph(BindingGraph bindingGraph);
	
	        @BindsInstance
	        Builder parentImplementation(
	                @ParentComponent Optional<ComponentImplementation> parentImplementation);
	
	        @BindsInstance
	        Builder parentRequestRepresentations(
	                @ParentComponent Optional<ComponentRequestRepresentations> parentRequestRepresentations);
	
	        @BindsInstance
	        Builder parentRequirementExpressions(
	                @ParentComponent Optional<ComponentRequirementExpressions> parentRequirementExpressions);
	
	        CurrentImplementationSubcomponent build();
	    }
	}

3.`xxx.componentImplementation()`,最终的目标是实例化`ComponentImplementation`对象，**前面的工作都是为了该对象实例化过程中需要的参数做准备**

	@Inject
    ComponentImplementation(
            @ParentComponent Optional<ComponentImplementation> parent,
            ChildComponentImplementationFactory childComponentImplementationFactory,
            // Inject as Provider<> to prevent a cycle.
            Provider<ComponentRequestRepresentations> bindingExpressionsProvider,
            Provider<ComponentCreatorImplementationFactory> componentCreatorImplementationFactoryProvider,
            BindingGraph graph,
            ComponentNames componentNames,
            CompilerOptions compilerOptions,
            DaggerElements elements,
            DaggerTypes types,
            KotlinMetadataUtil metadataUtil,
            XMessager messager) 

如上构造函数代码，

- 参数parent，自身`Component`类关联的父级`Component`，例如`TopLevelImplementationComponent`的所在父`Component`是`ProcessorComponent`

- 参数`childComponentImplementationFactory`，当前涉及的子ComponentImplementation来源，对应于上面的parent，下面会分析

- 参数`bindingExpressionsProvider`下面会分析

- 参数`componentCreatorImplementationFactoryProvider`不表

- 参数graph以及componentNames构造函数参数graph都是来源`ComponentGenerator的topLevelTypes`方法参数；

- 参数compilerOptions，elements，types，metadataUtil，messager不表；

**ComponentImplementation对几个重点参数来源解析**

1.`childComponentImplementationFactory`来源，如下图，生成子`ComponentImplementation`，依赖于当前`ComponentImplementation`

	@Module
    interface ChildComponentImplementationFactoryModule {
        @Provides
        static ComponentImplementation.ChildComponentImplementationFactory provideChildComponentImplementationFactory(
                CurrentImplementationSubcomponent.Builder currentImplementationSubcomponentBuilder,
                Provider<ComponentImplementation> componentImplementatation,
                Provider<ComponentRequestRepresentations> componentRequestRepresentations,
                Provider<ComponentRequirementExpressions> componentRequirementExpressions) {
            return childGraph ->
                    currentImplementationSubcomponentBuilder
                            .bindingGraph(childGraph)
                            .parentImplementation(Optional.of(componentImplementatation.get()))
                            .parentRequestRepresentations(Optional.of(componentRequestRepresentations.get()))
                            .parentRequirementExpressions(Optional.of(componentRequirementExpressions.get()))
                            .build()
                            .componentImplementation();
        }
    }

2.`bindingExpressionsProvider`

	@Inject
    ComponentRequestRepresentations(
            @ParentComponent Optional<ComponentRequestRepresentations> parent,
            BindingGraph graph,
            ComponentImplementation componentImplementation,
            ComponentRequirementExpressions componentRequirementExpressions,
            LegacyBindingRepresentation.Factory legacyBindingRepresentationFactory,
            DaggerTypes types,
            CompilerOptions compilerOptions)

重点看的是`LegacyBindingRepresentation.Factory`，涉及`@AssistedFactory`和`@AssistedInject`注解的使用，如下源码，只有当前的`create`方法被调用才会实例化`LegacyBindingRepresentation`对象，并且使用该对象

	@AssistedFactory
    static interface Factory {
        LegacyBindingRepresentation create(
                boolean isFastInit,
                Binding binding,
                SwitchingProviders switchingProviders
        );
    }

那么以上的`create`方法在那里调用的（说的有点傻，`Factory`实例化是在`ComponentRequestRepresentations`，那么肯定是在`ComponentRequestRepresentations`中调用`create`方法的喽）

> create调用代码目前还没写到，感兴趣可以看源码，这里的目的都是关联上，联通即可

源码如下,`legacyBindingRepresentationFactory.create`的调用生成：

	RequestRepresentation getRequestRepresentation(BindingRequest request) {
	   ...
	BindingRepresentation representation =
        legacyBindingRepresentationFactory.create(isFastInit(), binding, switchingProviders);
	   ...
	}

`LegacyBindingRepresentation`类中还有千千万万个类似的`@AssistedFactory`和`@AssistedInject`,不表了，我都懒得看，后面源码解析再去理解，这些方法都是为了关联Component注解生成代码，复杂度比较高（当然了，看你怎么看，花几个小时理解了这些作用也就那样，不理解一直都比较懵逼）

# 总结 #

写的啥玩意这是！！！但是真的是将核心地段通透了一遍了。3,4两章啥都没做，都是为了实例化对象，提供实例化对象参数的实例化。这就是Dagger的作用，**实例化对象，提供实例化对象参数，并且将对象通过一个中心控制器注入到需要的类中**



# 本章版本 #

本章打个版本，[dagger源码解析](https://github.com/hellogaod/DaggerCodeParse-2.38.1base) 版本V0.3

