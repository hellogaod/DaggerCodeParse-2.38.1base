# 前言 #

前面主要针对component及其关联的subcomponent、module、bindingMethod、Inject等核心注解的解析，下面对一些其他注解讲解。

> 当然这里还是针对ComponentProcessor下的注解讲解。

# 其他注解的讲解 #

## MapKey注解 ##

MapKeyProcessingStep类中实现具体的业务逻辑。

@MayKey注解仅仅用于修饰注解。

**规则如下：**

1. 如果MapKey.unwrapValue() = true的情况下，被修饰的注解类方法有且仅有一个，并且该方法的返回类型不可以是TypeKind.ARRAY数组；

2. 如果MapKey.unwrapValue() = false，被修饰的注解类方法可以有多个，并且当前项目必须引用com.google.auto.value.AutoAnnotation;

**生成代码：**

分为两种情况：

1. 如果unwrapValue = false，使用AnnotationCreatorGenerator类完成业务逻辑，具体如下：

 - （1）类名 MapKey修饰的注解名称（如果该注解是内部类，那么使用"_"拼接直到当前注解） + "Creator"；

 - （2）public final修饰该生成类，并且生成一个private修饰的无参构造函数；

 - （3）对当前 MapKey修饰的注解以及它的所有方法返回类型是注解（深入遍历所有注解）在当前生成类中生成方法：
  
 - ① 方法名："create" + 当前注解名；

 - ② 方法使用AutoAnnotation注释，返回类型是注解类型；public statc修饰；

 - ③ 当前生成的方法参数是当前注解中所有方法的返回类型；

 - ④ 当前方法代码块：`return new $T($L)`，$T:"AutoAnnotation_" + 当前注解名称 + "_" + 当前方法名,$L:参数以逗号分隔;（这里是为了符合AutoAnnotation注释生成规则）；

2. 如果unwrapValue = true（默认为true），并且MapKey修饰的注解中有且仅有的唯一方法返回类型还是一个注解，使用UnwrappedMapKeyGenerator类完成业务逻辑，具体如下：

 - 雷同于上面AnnotationCreatorGenerator类完成业务逻辑，唯一的不同是对MapKey修饰的注解的方法返回类型是注解（深入遍历所有注解）生成方法规则相同；这里我们看到和上面的区别在于没有包含MapKey修饰的注解。


如果unwrapValue = true（默认就是true），并且唯一的方法返回类型不是注解类型，那么不需要做任何生成工作。这种也是非常常用的，而且不容易出错。

## ProductionComponent或ProductionSubcomponent注解 ##

如果使用的是Production(Sub)Component，那么还需要生成额外的代码，该代码的作用是监控。

MonitoringModuleProcessingStep类中使用MonitoringModuleGenerator执行业务逻辑操作，生成一个类，规则如下：

1. 类名是 component节点(如果是内部类，那么使用"_"拼接到当前component节点) 拼接 "_MonitoringModule"，生成的类是抽象类，使用Module注解修饰；

2. 添加private修饰的无参构造函数；

3. 生成名为setOfFactories方法，该方法是抽象方法，Multibinds注解修饰该方法，方法返回类型是Set<ProductionComponentMonitor.Factory>；

4. 生成名为monitor方法，返回类型是ProductionComponentMonitor，static修饰，使用Provides和ProductionScope注解修饰；

 - （1）添加两个参数component（类型是当前component节点）和factories（Set<ProductionComponentMonitor.Factory>）；

 - （2）当前方法代码块：`return Monitors.createMonitorForComponent(component, factories)`；


## 总结 ##

内容不多，但是精确就好~

可在QQ群：575306647 讨论

[源码解析github地址](https://github.com/hellogaod/DaggerCodeParse-2.38.1base)