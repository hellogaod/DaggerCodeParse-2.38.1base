# 前言 #

`AndroidEntryPointProcessor`类处理@AndroidEntryPoint和@HiltAndroidApp注解。当前使用该注解的节点校验并且生成`AndroidEntryPointMetadata`对象，针对该`AndroidEntryPointMetadata对象再生成类。

# 校验并生成AndroidEntryPointMetadata对象 #

使用@AndroidEntryPoint或@HiltAndroidApp注解修饰的节点规则校验，校验过程中生成AndroidEntryPointMetadata对象。

## 校验规则 ##

1. 节点使用@HiltAndroidApp或@AndroidEntryPoint注解修饰有且仅有一个；

2. @HiltAndroidApp或@AndroidEntryPoint注解只能用于修饰类，而不能用于修饰接口;

3. @HiltAndroidApp或@AndroidEntryPoint注解修饰的类不能使用泛型；

4. 判断 - @HiltAndroidApp或@AndroidEntryPoint注解修饰的类禁止超类验证 && @HiltAndroidApp或@AndroidEntryPoint注解的value值是Void.class类型：

 - 4.1 true： @HiltAndroidApp或@AndroidEntryPoint注解修饰的类不是kotlin文件 || 如果是kotlin文件，那么该类存在不是默认参数的构造函数；

 - 4.2 false：

 - ① @HiltAndroidApp或@AndroidEntryPoint注解的value值不能是Void类型；

 - ② @HiltAndroidApp或@AndroidEntryPoint注解修饰的类$CLASS extends Hilt_$CLASS；

5. @HiltAndroidApp或@AndroidEntryPoint注解的value值类型，不能是@HiltAndroidApp或@AndroidEntryPoint注解修饰的类；

6. baseElement表示@HiltAndroidApp或@AndroidEntryPoint注解的value值节点（或@HiltAndroidApp或@AndroidEntryPoint注解修饰的类的父类），如果baseElement使用了@HiltAndroidApp或@AndroidEntryPoint注解修饰：

 - (1) @HiltAndroidApp或@AndroidEntryPoint注解修饰的类 和 其baseElement节点要么都使用@WithFragmentBindings注解修饰，要么都不要使用该注解；

 - (2) @HiltAndroidApp或@AndroidEntryPoint注解修饰的类不要使用@OptionalInject修饰的注解修饰 || baseElement类型使用@OptionalInject修饰的注解修饰；

7. @HiltAndroidApp只能用于修饰Application的继承类；

8. @AndroidEntryPoint可用于修饰Activity、Service、Broadcast_service,Fragment,View：

 - （1）@AndroidEntryPoint用于修饰Activity时，只能修饰androidx.activity.ComponentActivity的继承节点；

 - （2）@AndroidEntryPoint不能用于修饰Application的继承类。

## AndroidEntryPointMetadata对象属性 ##

1. TypeElement element: @HiltAndroidApp或@AndroidEntryPoint注解修饰的类;

2. TypeElement baseElement: @HiltAndroidApp或@AndroidEntryPoint注解的value值节点或@HiltAndroidApp或@AndroidEntryPoint注解修饰的类的父类;

3. ClassName generatedClassName:@HiltAndroidApp或@AndroidEntryPoint注解修饰的类$CLASS生成的类名 - Hilt_$CLASS；

4. boolean requiresBytecodeInjection: 判断 - @HiltAndroidApp或@AndroidEntryPoint注解修饰的类禁止超类验证 && @HiltAndroidApp或@AndroidEntryPoint注解的value值是Void.class类型;

5. AndroidEntryPointMetadata.AndroidType androidType: Type类的androidType属性；

6. Optional<AndroidEntryPointMetadata> baseMetadata:baseElement（或其父节点）如果使用了@HiltAndroidApp或@AndroidEntryPoint注解修饰，生成的AndroidEntryPointMetadata对象；

7. ImmutableSet<ClassName> installInComponents:Type类的component属性；

8. TypeName componentManager:Type类的manager属性；

9. Optional<CodeBlock> componentManagerInitArgs:Type类的componentManagerInitArgs属性；

## Type ##

该类主要有以下四个属性：

1. ClassName component;
2. AndroidType androidType;
3. ClassName manager;
4. CodeBlock componentManagerInitArgs。

针对Application、service、broadcast_receiver、activity、fragment和view组件采用不同处理。

### Application ###

1. ClassName component：SingletonComponent接口；
2. AndroidType androidType：AndroidType.APPLICATION；
3. ClassName manager：ApplicationComponentManager类
4. CodeBlock componentManagerInitArgs：null。


### Service ###

1. ClassName component：ServiceComponent接口；
2. AndroidType androidType：AndroidType.SERVICE；
3. ClassName manager：ApplicationComponentManager类
4. CodeBlock componentManagerInitArgs：CodeBlock.of("this")。

### Broadcast_Receiver ###

1. ClassName component：SingletonComponent接口；
2. AndroidType androidType：AndroidType.BROADCAST_RECEIVER；
3. ClassName manager：BroadcastReceiverComponentManager类
4. CodeBlock componentManagerInitArgs：null。

### Activity ###

1. ClassName component：ActivityComponent接口；
2. AndroidType androidType：AndroidType.ACTIVITY；
3. ClassName manager：ActivityComponentManager类;
4. CodeBlock componentManagerInitArgs：CodeBlock.of("this")。

### Fragment ###

1. ClassName component：FragmentComponent接口；
2. AndroidType androidType：AndroidType.FRAGMENT；
3. ClassName manager：FragmentComponentBuilderEntryPoint类;
4. CodeBlock componentManagerInitArgs：CodeBlock.of("this")。

### View ###

1. ClassName component：ViewWithFragmentComponent接口；
2. AndroidType androidType：AndroidType.VIEW；
3. ClassName manager：ViewComponentManager类;
4. CodeBlock componentManagerInitArgs：CodeBlock.of("this, true /* hasFragmentBindings */")。


### View no fragment ###

1. ClassName component：ViewComponent接口；
2. AndroidType androidType：AndroidType.VIEW；
3. ClassName manager：ViewComponentManager类;
4. CodeBlock componentManagerInitArgs：CodeBlock.of("this, false /* hasFragmentBindings */")。


# 生成类 #

调用gnerate()方法生成不同类。

## InjectorEntryPointGenerator ##

1. 生成的类名是@HiltAndroidApp或@AndroidEntryPoint注解修饰的节点拼接：$CLASS_GeneratedInjector；

2. 生成的一定是public修饰的接口：

 - (1)添加注解：`@OriginatingElement(topLevelClass = @HiltAndroidApp或@AndroidEntryPoint注解修饰的节点类型.class)`,
 - (2)添加`@GeneratedEntryPoint`注解，
 - (3)添加`@InstallIn`注解；
 - (4)添加`@Generated("InjectorEntryPointGenerator")`注解；
 - (5)如果@HiltAndroidApp或@AndroidEntryPoint注解修饰的节点使用了@TargetApi注解修饰，把当前@TargetApi注解拷贝过来；

3. 添加`public abstract`(接口不需要abstract修饰)修饰的方法：

 - （1）方法名：inject$Class - inject拼接@HiltAndroidApp或@AndroidEntryPoint注解修饰的节点（Foo.Bar.Baz -> injectFoo_Bar_Baz）；

 - （2）方法参数：类型 - 当前@HiltAndroidApp或@AndroidEntryPoint注解修饰的节点类型；参数名 - 当前@HiltAndroidApp或@AndroidEntryPoint注解修饰的节点类型首字母小写

demo如下：

    @AndroidEntryPoint
    public FooActivity extends ComponentActivity{}

生成代码：

 	 @Generated("InjectorEntryPointGenerator")
     @InstallIn(ActivityComponent.class)
     @GeneratedEntryPoint
     @OriginatingElement(topLevelClass = FooActivity.class)
     public interface FooActivity_GeneratedInjector {
       void injectFooActivity(FooActivity fooActivity);
     }

>使用@HiltAndroidApp或@AndroidEntryPoint注解修饰的节点都会生成以上`$CLASS_GenratedInjector`接口。

当前生成的接口根据注解一定会进行代码的再次生成。所以后面学习过程中要回过头温习。

## ApplicationGenerator ##

@HiltAndroidApp修饰的Application实现类生成代码。

1. 生成的是一个abstract抽象类，类名：Hilt_$APP，$APP表示@HiltAndroidApp修饰的节点；

2. Hilt_$APP类继承Application；

3. 如果@HiltAndroidApp修饰的节点是kotlin文件，那么当前 Hilt_$APP抽象类使用public修饰；

4. 添加`private final`修饰的变量:`private final ApplicationComponentManager componentManager =xxx`;

5. 添加继承方法`componentManager`;

6. Hilt_$APP类添加注释：`A generated base class to be extended by the @HiltAndroidApp annotated class. If using the Gradle plugin, this is swapped as the base class via bytecode transformation.`

7. 添加注解：`@Generated("ApplicationGenerator")`；

8. baseElement如果存在泛型， 该泛型添加到Hilt_$APP类上；

9. 如果@HiltAndroidApp修饰的节点使用了TargetApi注解，拷贝到Hilt_$APP类上；

10. 继承GeneratedComponentManagerHolder接口，并且实现generatedComponent方法（在当前element生成的AndroidEntryPointMetadata对象的baseMetadata不存在的情况下才会继承并且生成方法）：

11. 实现继承方法`onCreate`，添加@CallSuper注解；


生成的代码如下：

	//A generated base class to be extended by the @HiltAndroidApp annotated class. If using the Gradle plugin, this is swapped as the base class via bytecode transformation.
     @Generated("ApplicationGenerator")
     abstract class Hilt_$APP extends $BASE implements GeneratedComponentManagerHolder {

            private final ApplicationComponentManager componentManager =
	         new ApplicationComponentManager(
	          new ComponentSupplier() {
	              @Override
	              public Object get() {
	               return DaggerSingletonComponent.builder()
	                   .applicationContextModule(new ApplicationContextModule(Hilt_$APP.this))
	                  .build();
	               }
	           }
	         );

		@Override
	     public final ApplicationComponentManager componentManager() {
	       return componentManager;
	     }

		@Override
	     public final Object generatedComponent() {
	       return this.componentManager().generatedComponent();
	     }

	 	 @CallSuper
	     @Override
	     public void onCreate() {
	       // This is a known unsafe cast, but is safe in the only correct use case:
	       // $APP extends Hilt_$APP
	       (($APP_GeneratedInjector)generatedComponent()).inject$APP(($APP) this);
	       super.onCreate();
	     }
     }

## ActivityGenerator ##

@AndroidEntryPoint修饰的Activity实现类生成代码。


业务代码比较简单，直接上生成的代码：

    //A generated base class to be extended by the @AndroidEntryPoint annotated class. If using  the Gradle plugin, this is swapped as the base class via bytecode transformation.
     @Generated("ActivityGenerator")
     abstract class Hilt_$CLASS extends $BASE implements GeneratedComponentManagerHolder {

		private volatile ComponentManager componentManager;
		private final Object componentManagerLock = new Object();

	 	protected ActivityComponentManager createComponentManager() {
	       return new ActivityComponentManager(this);
	     }

		@Override
		public final ActivityComponentManager componentManager(){

			if (earlyComponent == null) {
		      synchronized (componentManagerLock) {
		        if (componentManager == null) {
		          componentManager = createComponentManager();
		        }
		      }
		    }

		    return componentManager;
		}

		private boolean injected = false;

		protected void inject() {
	       if (!injected) {
	         (($CLASS_GeneratedInjector)this.generatedComponent()).inject$CLASS(($CLASS) this);
	         injected = true;
	       }
	     }

	     private void _initHiltInternal() {
	       addOnContextAvailableListener(new OnContextAvailableListener() {
	         @Override
	         public void onContextAvailable(Context context) {
	           inject();
	         }
	       });
	     }

		 @Override
	     public final Object generatedComponent() {
	       return this.componentManager().generatedComponent();
	     }

     }



## BroadcastReceiverGenerator ##


@AndroidEntryPoint修饰的BroadcastReceiver实现类生成代码。

生成的代码如下：

	@Generated("BroadcastReceiverGenerator")
    abstract class Hilt_$CLASS extends $BASE {

		private volatile boolean injected = false;
		private final Object injectedLock = new Object();

 		protected void inject(Context context) {
	       if (!injected) {
				synchronized (injectedLock){
					if (!injected){
						(($CLASS_GeneratedInjector)BroadcastReceiverComponentManager.generatedComponent(context)).inject$CLASS(($CLASS) this);
					}
				}
	         
	         injected = true;
	       }
	     }

         @CallSuper
	     @Override
	     public void onReceive(Context context, Intent intent) {
	       inject(context);
	       super.onReceive(context, intent);
	     }

    }


## FragmentGenerator ##

AndroidEntryPoint修饰的Fragment实现类生成代码如下：

	//A generated base class to be extended by the @AndroidEntryPoint annotated class. If using the Gradle plugin, this is swapped as the base class via bytecode transformation.
     @Generated("FragmentGenerator")
     @SuppressWarnings("deprecation")
     abstract class Hilt_$CLASS extends $BASE implements GeneratedComponentManagerHolder {
       
		 private ContextWrapper componentContext;

		 private boolean injected = false;
		 protected void inject() {
	       if (!injected) {
	         (($CLASS_GeneratedInjector)this.generatedComponent()).inject$CLASS(($CLASS) this);
	         injected = true;
	       }
	     }

		 private volatile FragmentComponentManager componentManager;

	 	 protected FragmentComponentManager createComponentManager() {
	       return new FragmentComponentManager(this);
	     }

	     @Override
	     public FragmentComponentManager componentManager() {
	       if (componentManager == null) {
	         synchronize (componentManagerLock) {
	           if (componentManager == null) {
	             componentManager = createComponentManager();
	           }
	         }
	       }
	       return componentManager;
	     }

		 @CallSuper
	     @Override
	     public void onAttach(Context context) {
	       super.onAttach(context);
	       initializeComponentContext();
	       inject();
	     }

		 @CallSuper
	     @MainThread
	     @Override
	     public void onAttach(Activity activity) {
	       super.onAttach(activity);
	       Preconditions.checkState(
	           componentContext == null || FragmentComponentManager.findActivity(
	               componentContext) == activity, "...");
	       initializeComponentContext();
	       inject();
	     }

	 	private void initializeComponentContext() {
	       if (componentContext == null) {
	         // Note: The LayoutInflater provided by this componentContext may be different from super
	         // Fragment's because we are getting it from base context instead of cloning from super
	         // Fragment's LayoutInflater.
	         componentContext = FragmentComponentManager.createContextWrapper(super.getContext(), this);
	       }
	     }

		@Override
	     public Context getContext() {
	       if (super.getContext() == null) 
	         return null;
	       initializeComponentContext();
	       return componentContext;
	     }

		 @Override
	     public LayoutInflater onGetLayoutInflater(Bundle savedInstanceState) {
	       LayoutInflater inflater = super.onGetLayoutInflater(savedInstanceState);
	       return LayoutInflater.from(FragmentComponentManager.createContextWrapper(inflater, this));
	     }

		 @Override
	     public final Object generatedComponent() {
	       return this.componentManager().generatedComponent();
	     }

		 @Override
	     public ViewModelProvider.Factory getDefaultViewModelProviderFactory() {
	       return DefaultViewModelFactories.getFragmentFactory(
	           this, super.getDefaultViewModelProviderFactory());
	     }
     }



## ServiceGenerator ##

AndroidEntryPoint修饰的Service实现类生成代码如下：

    //A generated base class to be extended by the @AndroidEntryPoint annotated class. If using the Gradle plugin, this is swapped as the base class via bytecode transformation.
    @Generated("ServiceGenerator")
    abstract class Hilt_$CLASS extends $BASE {

		private boolean injected = false;

	 	protected void inject() {
	       if (!injected) {
	         generatedComponent().inject$CLASS(($CLASS) this);
	         injected = true;
	       }
	     }

		private final Object componentManagerLock = new Object();

		private volatile ServiceComponentManager componentManager;

		protected ServiceComponentManager createComponentManager() {
	       return new ServiceComponentManager(this);
	     }

		@Override
	     public ServiceComponentManager componentManager() {
	       if (componentManager == null) {
	         synchronize (componentManagerLock) {
	           if (componentManager == null) {
	             componentManager = createComponentManager();
	           }
	         }
	       }
	       return componentManager;
	     }

       @CallSuper
	   @Override
	   public void onCreate() {
	     inject();
	     super.onCreate();
	   }

		 @Override
	     public final Object generatedComponent() {
	       return this.componentManager().generatedComponent();
	     }

    }

## ViewGenerator ##

AndroidEntryPoint修饰的View实现类生成代码如下：

  	//A generated base class to be extended by the @AndroidEntryPoint annotated class. If using the Gradle plugin, this is swapped as the base class via bytecode transformation.
    @Generated("ViewGenerator")
    abstract class Hilt_$CLASS extends $BASE implements GeneratedComponentManagerHolder {

		private boolean injected;

	 	protected void inject() {
	       if (!injected) {
	          (($CLASS_GeneratedInjector)this.generatedComponent()).inject$CLASS(($CLASS) this);
	         injected = true;
	       }
	     }

	    private volatile ViewComponentManager componentManager;

	 	protected ViewComponentManager createComponentManager() {
	       return new ViewComponentManager(this,true);
	     }

		@Override
	     public ViewComponentManager componentManager() {
	       
	       componentManager = createComponentManager();
	           
	       return componentManager;
	     }

        @Override
        public final Object generatedComponent() {
          return this.componentManager().generatedComponent();
        }

    }

# 总结 #

以上代码生成结束，可以看出还会有进一步处理。

