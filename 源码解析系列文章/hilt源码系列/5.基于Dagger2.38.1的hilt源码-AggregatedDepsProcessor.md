# 前言 #

本篇主要是处理@InstallIn和@TestInstallIn、@Module、@EntryPoint和@EarlyEntryPoint和@GeneratedEntryPoint和@ComponentEntryPoint注解。这些注解只能用于修饰类或接口。

# 校验并且生成PkgPrivateMetadata对象 #

## 校验规则 ##

1. @InstallIn和@TestInstallIn:当前节点只允许使用其中的一个注解，只允许使用一次；

2. @EntryPoint、@EarlyEntryPoint、@GeneratedEntryPoint和@ComponentEntryPoint:当前节点只允许使用其中的一个注解，只允许使用一次；

3. @Module:当前节点只允许使用一次Module注解；

4.  @InstallIn或@TestInstallIn注解修饰的节点。该节点要么使用@Module修饰，要么使用@EntryPoint或@EarlyEntryPoint或@GeneratedEntryPoint或@ComponentEntryPoint修饰；

5. @Module修饰的节点不允许同时使用@EntryPoint或@EarlyEntryPoint或@GeneratedEntryPoint或@ComponentEntryPoint修饰;

6. @InstallIn或@TestInstallIn注解修饰的节点同时使用@Module修饰，我们称之为module节点：

 - （1）module节点必须是类或接口；

 - （2）module节点是顶级类（再上一级就是包） || module节点使用static修饰 || module节点使用abstract修饰 || module节点的父节点使用@HiltAndroidTest修饰；

 - （3）module节点是ApplicationContextModule类 || module节点不需要实例化（module节点何时需要实例化：module节点中的所有bindingMethod方法既不是static就是也不是abstract修饰，并且module不是 Kotlin compainionObject类型） || module不存在构造函数，或者构造函数无参并且没有使用private修饰；

 - （4） module节点中abstract修饰的bindingMethod方法必须使用@Binds或@Multibinds或@Provides或@BindsOptionalOf修饰；

 - （5）@TestInstallIn修饰的module节点不能嵌套在（或源自）@HiltAndroidTest 注释的类中；

 - （6）@TestInstallIn注解的replaces方法必须存在至少一个值；

 - （7） @TestInstallIn注解的replaces方法中的值类型必须使用@InstallIn修饰；

 - （8）@TestInstallIn#replaces()中的值类名称不允许使用"HiltWrapper_"作为开头；

 - （9） 如果当前module节点所在的包路径不是dagger.hilt开头，那么@TestInstallIn#replaces()的值类也不能在dagger.hilt开头开头的包下；

 - （10）@TestInstallIn#replaces()的值类型不能嵌套在（或源自）@HiltAndroidTest 注释的类中；

7.  @InstallIn或@TestInstallIn注解修饰的节点同时使用@EntryPoint或@EarlyEntryPoint或@GeneratedEntryPoint或@ComponentEntryPoint修饰，当前节点称之为entryPoint节点：

 - （1）@TestInstallIn注解只能和@Module一起使用，不能和@EntryPoint或@EarlyEntryPoint或@GeneratedEntryPoint或@ComponentEntryPoint一起使用；

 - （2）entryPoint节点只能是接口;

 - （3）@EarlyEntryPoint修饰的节点使用的注解@InstallIn的value值类型只能是SingletonComponent接口；

 - （4）@EarlyEntryPoint 修饰的节点 不能嵌套在（或源自）@HiltAndroidTest 修饰的类 中。 此要求是为了避免与其他特定于测试的入口点混淆。

8. @InstallIn的value值或者@TestInstallIn的components值类型 - 必须使用@DefineComponent修饰;

## 生成PkgPrivateMetadata对象属性 ##

使用@InstallIn或@TestInstallIn修饰的节点（该节点同时使用@Module修饰 或@EntryPoint、@EarlyEntryPoint、@GeneratedEntryPoint和@ComponentEntryPoint修饰），该节点存在不会生成当前PkgPrivateMetadata对象的情况：

1. 如果**该节点是public修饰类或接口（存在父级节点也是public修饰的类或接口），非kotlin文件**，那么不需要生成当前PkgPrivateMetadata对象；

2. 条件1不满足的情况下，在判断当前节点是使用@Module修饰的module节点，并且该module节点需要被实例化（module节点中的bindingMethod方法既不是static就是也不是abstract修饰，并且module不是 Kotlin compainionObject类型），那么不需要生成当前PkgPrivateMetadata对象。

**PkgPrivateMetadata对象属性如下：**

1. TypeElement typeElement：使用@InstallIn或@TestInstallIn修饰的节点类型（该节点同时使用@Module修饰 或@EntryPoint、@EarlyEntryPoint、@GeneratedEntryPoint和@ComponentEntryPoint修饰；

2. Optional<AnnotationMirror> optionalInstallInAnnotationMirror：当前节点使用的@InstallIn或@TestInstallIn注解；

3. ClassName annotation：当前节点使用的@Module 或 @EntryPoint、@EarlyEntryPoint、@GeneratedEntryPoint和@ComponentEntryPoint注解的ClassName类型；


# PkgPrivateModuleGenerator生成类 #

当前节点使用@InstallIn或@TestInstallIn修饰 并且使用 @Module修饰，并且该module节点非public修饰 ，并且当前module节点不需要实例化（实例化条件：module节点中的bindingMethod方法既不是static就是也不是abstract修饰，并且module不是 Kotlin compainionObject类型）。

demo：

	@InstallIn(ActivityComponent.class)
	@Module
	abstract MyModule(){}

生成的类如下：

     @Generated("PkgPrivateModuleGenerator")
     @InstallIn(ActivityComponent.class)
     @OriginatingElement(topLevelClass = MyModule.class)
     @Module(includes = MyModule.class)
     public final class HiltWrapper_MyModule {}

# PkgPrivateEntryPointGenerator生成类 #

当前节点使用@InstallIn或@TestInstallIn修饰 并且使用 @EntryPoint、@EarlyEntryPoint、@GeneratedEntryPoint和@ComponentEntryPoint修饰，并且该emtryPoint节点非public修饰。

demo：

	@InstallIn(ActivityComponent.class)
	@EntryPoint
	interface MyEntryPoint{}

生成的类如下：

	 @Generated("PkgPrivateEntryPointGenerator")
     @InstallIn(ActivityComponent.class)
     @OriginatingElement(topLevelClass = MyEntryPoint.class)
     @EntryPoint
     public interface HiltWrapper_MyEntryPoint implements MyEntryPoint  {
     }


# AggregatedDepsGenerator生成类 #

当前节点使用@InstallIn或@TestInstallIn修饰，并且使用@Module修饰的节点 或使用@EntryPoint、@EarlyEntryPoint、@GeneratedEntryPoint和@ComponentEntryPoint修饰,该节点使用public修饰，或者如果是module节点需要被实例化的情况下，使用当前对象生成相关类。


生成的类在hilt_aggregated_deps包下：

 //This class should only be referenced by generated code!This class aggregates information across multiple compilations.
    @AggregatedDeps(components =  @InstallIn的value值或者@TestInstallIn的components值类型,replaces = @TestInstallIn注解的replaces方法(只有在@Module和@TestInstallIn同时修饰时才会存在),test = 当前节点嵌套在（或源自）的@HiltAndroidTest修饰的节点ClassName类型,modules = 当前module节点名称, entry = 当前@EntryPoint、@EarlyEntryPoint或@GeneratedEntryPoint修饰的节点名称, componentEntryPoints = 当前@ComponentEntryPoint修饰的节点名称)
    @Generated("AggregatedDepsGenerator")
    public class $CLASS{}

> @AggregatedDeps注解的modules、entry和componentEntryPoints只能存在一个。

# 总结 #

解说到现在我都是一头蒙，到底啥玩意，继续往下看。答案等着我们去解答！！！期待！


