
# 前言 #

本篇基于2.38.1学习。

## android studio版本 ##

1. android stdio版本是2020.3.1

2. gradle plugin Version：7.0.1

> 插件是7.0.1，那么jdk只能用11或以上，jdk使用1.8会提示相关错误

3. gradle version ： 7.0.2

![在这里插入图片描述](https://img-blog.csdnimg.cn/0ab6c7a778b74ddcb139a58fb4c78ffa.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5L2b5a2m5b6SLeS7o-eggeaQrOi_kOW3pQ==,size_20,color_FFFFFF,t_70,g_se,x_16)

**依赖关系**

![在这里插入图片描述](https://img-blog.csdnimg.cn/f0622c837bb542e0942213712197bec9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5L2b5a2m5b6SLeS7o-eggeaQrOi_kOW3pQ==,size_12,color_FFFFFF,t_70,g_se,x_16)


> 其他版本我不清楚，当前版本会提现如上图所示的一种依赖关系，方便我们去查看依赖
 

## dagger里面三方jar包带来的坑 ##

> 贼坑，三方jar包引入本身存在冲突，例如bootstrap_compiler_deploy.jar和kythe_plugin_deploy.jar；而且给的jar既然还不是最新的，例如xprocessing.jar和上面两个jar，涉及到的每个jar都不是最新的。

因为三方jar的问题浪费了我太多时间，这些jar存在于源码中，jar里面文件的冲突可能因为需求原因，但是jar给的不是最新的，百思不得其姐和大爷。

千辛万苦，我已经一个个的把各个依赖都引入到源码实例总了，源码下面会留tag版本信息

**存在疑惑点**

前面章节讲到了，不明白ComponentProcessor里面也存在注解，但是Dagger逻辑代码存在于ComponentProcessor中，不能使ComponentProcessor注解有效。

> 当时给的答案是可能是bazel的一种福利，这个目前无法定论。但是这边给了答复，在bootstrap_cmpiler_deloy.jar中存在dagger包，里面包含已经生成了的逻辑代码，例如DaggerComponentProcessor_ProcessorComponent.java。但是，都不是最新的，也就是本案例中不能使用。

不过最终被我找到了解决办法，

>annotationProcessor 'com.google.dagger:dagger-compiler:2.38.1'

在源码的gradle里面加上以上代码（我给的源码这样不行，存在问题-需要引入以上说的三个jar，并且删冲突，添加不存在的依赖，反正很麻烦，这不是重点，所以不贴代码了）

# 框架图解 #

![在这里插入图片描述](https://img-blog.csdnimg.cn/4c6e14e8c89e4831bda623b4da1763a0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5L2b5a2m5b6SLeS7o-eggeaQrOi_kOW3pQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)

该图仅仅为了反映依赖注入ComponentProcessor，还有更多的依赖没有体现出来（都体现出来咱的吐血三升，已经试过了，太乱而且理解起来相当麻烦）。

反映这种关系就行，仅仅为了方便理解

>请对照代码仔细理解一遍（上面说的AS自带依赖图标配合），对后面的理解非常有效，代码以及做了非常多的简化了

# ComponentProcessor源码解析 #

## BasicAnnotationProcessor ##

该类继承了JavacBasicAnnotationProcessor，继承的方法会按照顺序相继执行，这个是针对BasicAnnotationProcessor源码的理解（前面章节虽然有所不同，但是应该已经满足理解的需求）

## DI（dependency inject，简称依赖注入） ##

**核心代码**

	ProcessorComponent.factory()
                .create(getXProcessingEnv(),testingPlugins.orElseGet(this::loadExternalPlugins))
                .inject(this);

**1. 被Inject注释的对象实例化**

> ProcessorComponent.factory() .create(getXProcessingEnv(),testingPlugins.orElseGet(this::loadExternalPlugins))

调用`DaggerComponentProcessor_ProcessorComponent`构造函数，调用`initialize`实现具体实例化工作



**(1) injectBindingRegistry依赖关系，ComponentProcessor使用@Inject注释，如下：**

	@Inject
    InjectBindingRegistry injectBindingRegistry;

真正实例化的对象是InjectBindingRegistryImpl：

	@Binds InjectBindingRegistry injectBindingRegistry(InjectBindingRegistryImpl impl);

InjectBindingRegistryImpl构造函数,也就是说完成InjectBindingRegistryImpl的实例化必须有DaggerElements，DaggerTypes，XMessager，InjectValidator，CompilerOptions参数：

	@Inject
    InjectBindingRegistryImpl(
            DaggerElements elements,
            DaggerTypes types,
            XMessager messager,
            InjectValidator injectValidator,
            CompilerOptions compilerOptions) {

        this.elements = elements;
        this.types = types;
        this.messager = messager;
        this.injectValidator = injectValidator;
        this.compilerOptions = compilerOptions;
    }

InjectValidator来源于自身的构造函数：

 	@Inject
    InjectValidator(){}


DaggerElements，DaggerTypes，XMessager,CompilerOptions参数来源ProcessingEnvironmentModule类（该类存在于ProcessorComponent#modules中）：

	/**
	 * Bindings that depend on the {@link XProcessingEnv}.
	 */
	@Module
	interface ProcessingEnvironmentModule {
	
	    @Binds
	    @Reusable
	        // to avoid parsing options more than once
	    CompilerOptions bindCompilerOptions(
	            ProcessingEnvironmentCompilerOptions processingEnvironmentCompilerOptions
	    );
	
	    @Provides
	    @ProcessingOptions
	    static Map<String, String> processingOptions(XProcessingEnv xProcessingEnv) {
	        return xProcessingEnv.getOptions();
	    }
	
	    @Provides
	    static XMessager messager(XProcessingEnv xProcessingEnv) {
	        return xProcessingEnv.getMessager();
	    }
	   
	    @Provides
	    @Singleton
	    static DaggerElements daggerElements(XProcessingEnv xProcessingEnv) {
	        return new DaggerElements(
	                XConverters.toJavac(xProcessingEnv).getElementUtils(),
	                XConverters.toJavac(xProcessingEnv).getTypeUtils());
	    }
	
	    @Provides
	    @Singleton
	    static DaggerTypes daggerTypes(XProcessingEnv xProcessingEnv, DaggerElements elements) {
	        return new DaggerTypes(XConverters.toJavac(xProcessingEnv).getTypeUtils(), elements);
	    }
	
	}

其中CompilerOptions实际创建的是ProcessingEnvironmentCompilerOptions，该对象的构造函数如下：

	@Inject
    ProcessingEnvironmentCompilerOptions(
            @ProcessingOptions Map<String, String> options
    ) {
        this.options = options;
    }

该对象参数来源ProcessingEnvironmentModule类的processingOptions方法，该方法参数XProcessingEnv来源于：

	ProcessorComponent.factory()
                .create(getXProcessingEnv(),testingPlugins.orElseGet(this::loadExternalPlugins))

ProcessingEnvironmentModule类的daggerTypes方法参数DaggerElements来源于该类的daggerElements方法

所以，综上所述，创建一个InjectBindingRegistryImpl对象，必须先实例化它构造函数的参数：

1. DaggerElements ：ProcessingEnvironmentModule类的daggerElements方法,该类参数XProcessingEnv来源于外界的传递

2. DaggerTypes：ProcessingEnvironmentModule类的daggerTypes方法，该方法两个参数XProcessingEnv来源于外界的传递,DaggerElements来源于1

3. XMessager：ProcessingEnvironmentModule类的messager方法,该类参数XProcessingEnv来源于外界的传递

4. InjectValidator ： 来源于其自身的@Inject修饰的构造函数

5. CompilerOptions ： ProcessingEnvironmentModule类的bindCompilerOptions方法，该方法参数来源于ProcessingEnvironmentCompilerOptions构造函数，该构造函数的参数又来源于ProcessingEnvironmentModule类的processingOptions方法

**(2) injectBindingRegistry的实例化**

存在一个问题，例如实例化DaggerTypes之前是否必须实例化DaggerElements,因为他们之间的依赖（DaggerTypes的实例化需要传递DaggerElements参数）

> 答案是肯定的，一定会先行实例化作为别的对象依赖的对象。

在DaggerComponentProcessor_ProcessorComponent的initialize方法中，会按照先后顺序实例化。

有一个很严重的问题，dagger如何确保他们之间的先后顺序，或者说如果DaggerTypes的实例化需要传递DaggerElements参数，我如何确保DaggerElements一定是在DaggerTypes之前实例化的

> 保不准必须DaggerElements实例化先写，这样根据先后顺序就行，那如果在不同Module中，并且不同Module中相互会使用对方的方法呢？？？

这个时候有个很重要的概念，**有向图**

![在这里插入图片描述](https://img-blog.csdnimg.cn/6f97f110d443474e928c4b74e25ed22a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5L2b5a2m5b6SLeS7o-eggeaQrOi_kOW3pQ==,size_20,color_FFFFFF,t_70,g_se,x_16)


如上图所示有向图，根据该图可以得知，如果需要创建injectBindingRegistry实例，那么找到依赖，最终定位到create有向图入口。

所以有了这个有向图，再也不用担心顺序问题了。当然了，这个只是为了方便理解，真正的dagger有向图以及依赖要复杂的多，但是这个图为我们揭开了谜团。

**dagger参数之间的依赖关系是通过有向图关联的**

**2. 被Inject注释的对象实例化后注入当前ComponentProcessor对象**

> .inject(this);

inject调用injectComponentProcessor方法

例如完成injectBindingRegistry实例关联ComponentProcessor对象，执行：

	ComponentProcessor_MembersInjector.injectInjectBindingRegistry(instance, (InjectBindingRegistry) injectBindingRegistryImplProvider.get());

生成ComponentProcessor_MembersInjector对象，调用如下代码完成赋值功能：

	@InjectedFieldSignature("dagger.internal.codegen.ComponentProcessor.injectBindingRegistry")
    public static void injectInjectBindingRegistry(ComponentProcessor instance,
                                                   InjectBindingRegistry injectBindingRegistry) {
        instance.injectBindingRegistry = injectBindingRegistry;
    }


# 本章版本 #

本章打个版本，[dagger源码解析](https://github.com/hellogaod/DaggerCodeParse-2.38.1base) 版本V0.2


# 存在问题及解决办法 #

1.[升级jdk11 程序包xxx不可见，程序包xxx已在模块 java.base 中声明, 但该模块未将它导出到未命名模块](https://javaworklife.wordpress.com/2019/02/01/java-8-to-java-11-part-1/)





