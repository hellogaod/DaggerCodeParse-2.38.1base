# 前言 #

最终还是回来补充一下该部分知识点，不想做到心里存着疑问点。

component从componentMethod入口方法(存着依赖的方法)开始，根据当前依赖一步步匹配：

1. componentMethod依赖的key去匹配绑定对象的key；

2. 绑定对象的key再去匹配其他绑定对象的key，直到当前绑定对象不存在依赖，不需要进行下一步匹配；

3. 不存在依赖两种情况：

 - （1）当前绑定对象实例化不需要依赖于参数：e.g.Inject修饰的无参构造函数；
 - （2）当前绑定对象的key是外部传递的被实例化后的参数：creator节点中@BindsInstance修饰的方法参数就是传递的参数；

# ComponentImplementation核心：依赖匹配梳理 #

该章节是即`8.1.Dagger2.38.1源码解析-Demo梳理component节点生成代码`基础上的总结。

> 切入点：ComponentImplementation.generate -> ShardImplementation.generate -> addInterfaceMethods  -> ComponentRequestRepresentations.getComponentMethod。


## 绑定对象 ##

具体自行查看关系图，`多种类型查询总结`，归纳为三种绑定对象：MembersInjectionBinding对象、ProvisionBinding对象、ProductionBinding对象。

MembersInjectionBinding对象：为了将该对象属性Key中的type表示的类使用@Inject修饰的变量或普通方法的参数进行实例化，去ProvisionBinding对象或ProductionBinding对象中匹配。

ProvisionBinding对象和ProductionBinding对象：不同绑定类型，为MembersInjectionBinding对象、ProvisionBinding对象或ProductionBinding对象的依赖提供匹配：依赖的key匹配当前对象的key；

### 哪些条件下生成MembersInjectionBinding对象 ###

依赖的key的type如果是MembersInjector< T>都可以，列出来下面几种：

1. componentMethod方法无参并且返回类型是MembersInjector< T>,T生成MembersInjectionBinding；

2. componentMethod返回类型既不是subcomponent又不是subcomponent.creator，有且仅有一个参数，当前参数生成MembersInjectionBinding; -正常用法

3. module节点中的被@Produces或@Provides或@Binds修饰的bindingMethod方法中的参数类型是MembersInjector< T>,T生成MembersInjectionBinding；

4. Inject或AssistedInject修饰的构造函数的参数如果使用了MembersInjector< T>,T生成MembersInjectionBinding；

5. Inject修饰的变量（或普通方法的参数）如果使用了MembersInjector< T>,T生成MembersInjectionBinding；

**依赖的key的type类型是MembersInjector< T> 和componentMethod返回类型既不是subcomponent又不是subcomponent.creator，有且仅有一个参数，当前参数生成MembersInjectionBinding区别在哪里**？

**依赖的key的type类型是MembersInjector< T>不仅仅作为MembersInjectionBinding对象，并且还会还会将当前MembersInjectionBinding对象转换成ProvisionBinding对象收集。**
	

### 哪些条件下生成ProvisionBinding对象 ###

1. Provides修饰的bindingMethod生成ProvisionBinding对象-属性对照component节点关系图；

2. Inject或AssistedInject修饰构造函数生成ProvisionBinding对象 - 属性对照component节点关系图；

3. component节点生成ProvisionBinding对象；

4. componentAnnotation#dependencies()里面的dependency节点生成ProvisionBinding绑定对象；

5. 如果component不是production类型，componentAnnotation#dependencies中的dependency节点中无参
&& 返回类型不是void的方法生成ProvisionBinding绑定对象；

6. creator节点中使用BindsInstance修饰的方法（或方法参数），该方法或方法参数作为bindingElement，
该方法的参数根据RequestKind剥离外壳作为type生成key——生成ProvisionBinding对象;

7. 当前component中的方法的返回类型是一个subcomponent.creator(其实Builder模式)，并且该subcomponent不在componentAnnotation#modules以及关联的moduleAnnotation#subcomponents的集合中，生成ProvisionBinding对象属性;

8. 被依赖匹配上的@Binds修饰的bindingMethod方法生成的DelegateDeclaration对象转换成ContributionBinding对象，如果当前DelegateDeclaration对象的依赖的key钥匙匹配上的是ProvisionBinding对象，那么当前DelegateDeclaration对象转换成ProvisionBinding对象;

9. （1）@Provides或@Produces或@Binds修饰的bindingMethod，该bindingMethod还使用了@IntoMap或@IntoSet或@ElementsIntoSet、（2）@Multibinds修饰的bindingMethod方法。如果依赖匹配上（1）或（2），那么 ①如果key的type是Map<K,X>,这个X不是Producer< T>
也不是Produced< T>,②如果key的type是Set< X>,X不是 Produced< T>,③又或者匹配上的那个@Binds修饰的bindingMethod生成的DelegateDeclaration转换的是ProvisionBinding，①②③依次判断，生成的ProvisionBinding对象；

10. 如果依赖的key及其变异的type类型是Optional< T>，那么把type改成T生成新的newkey如果匹配到@BindsOptionalOf修饰的bindingMethod，存在以下情况；
（1）并且newkey如果没有匹配到了Binding绑定对象，那么newkey生成ProvisionBinding对象;
（2）如果newKey钥匙匹配到了Binding绑定对象，但是匹配上的该Binding绑定对象不是ProductionBinding && newKey的type没有 使用Producer< T>类型也没用使用Produced< T>类型，生成ProvisionBinding对象;

11. 依赖匹配上component关联的module类的注解moduleAnnotation#subcomponents()里面的类生成的
SubcomponentDeclaration，生成ProvisionBinding对象；

12. 如果依赖的key钥匙的type类型是MembersInjector< T>,type作为key唯一属性，对T作为type生成新的newKey钥匙，newKey生成MembersInjectionBinding对象存储于InjectRegistryImpl，并且key钥匙和MembersInjectionBinding对象生成新的ProvisionBinding对象;

13. 如果依赖的key的type使用了AssistedFactory修饰，该type生成ProvisionBinding对象;

14. 如果依赖的key钥匙匹配过程中一个都没有匹配到，那么当前key的type是否使用了AssistedInject或Inject的构造函数集合，如果是，则对该构造函数生成ProvisionBinding对象；

 - 注：这个和2是完全一致的，只是这里解释了为什么key会匹配到AssistedInject或Inject的构造函数。

### 哪些条件下生成ProductionBinding对象 ###

1. Produces修饰的bindingMethod方法生成ProductionBinding对象；

2.  如果component是production类型，componentAnnotation#dependencies中的dependency节点中无参 &&
 返回类型不是void的方法生成ProductionBinding绑定对象;

3. 被依赖匹配上的@Binds修饰的bindingMethod方法生成的DelegateDeclaration对象转换成ContributionBinding对象，如果当前DelegateDeclaration对象的参数（依赖的key钥匙）匹配上的是ProductionBinding对象，那么当前DelegateDeclaration对象转换成ProductionBinding对象；

4. （1）@Provides或@Produces或@Binds修饰的bindingMethod，该bindingMethod还使用了@IntoMap、@IntoSet或@ElementsIntoSet、（2）@Multibinds修饰的bindingMethod方法 。如果依赖匹配上（1）或（2），那么 ①如果key的type是Map<K,X>,这个X是Producer< T>或是Produced< T>不做②③判断,
②如果key的type是Set< X>,X是 Produced< T>不做③判断,③又或者匹配上的那个@Binds修饰的bindingMethod生成的DelegateDeclaration转换的是ProductionBinding，满足①或①②或①②③条件生成的ProductionBinding对象；

5. 依赖的key的type是Optional< T>，那么把type改成T生成新的newkey如果匹配到@BindsOptionalOf修饰的bindingMethod,如果newKey钥匙匹配到了Binding绑定对象，匹配上的该Binding绑定对象ProductionBinding || newKey的type使用Producer< T>类型或使用Produced< T>类型，生成的ProductionBinding对象。

 - @ProductionComponent、@ProductionSubcomponent、@ProducerModule和@ProductionBinding有关联不？


## 匹配 ##

### 根据绑定类型判断 ###

#### 匹配到MembersInjectionBinding对象 ####

定位到MembersInjectionRequestRepresentation：该类的作用就是处理MembersInjectionBinding对象：@Inject修饰的变量或普通方法的参数在component容器中实例化，在xx_MembersInjector类中赋值工作。

#### 匹配到ProvisionBinding对象 ####

-----**插播 RequestKind类型说明 start** ---------------

**INSTANCE**：（1）使用T；没有使用任何类型对象包裹；（2）@Provides或@Produces或@Binds修饰的bindingMethod使用@IntoSet或@ElementIntoSet生成的依赖的kind属性

**PROVIDER**：（1）Provider< T>类型对象；（2）Produces修饰的bindingMethod方法生成的ProductionBinding对象里面会  生成两个属性：monitorRequest 和executorRequest，这两个依赖的kind类型都是 PROVIDER类型；（3）如果key的type使用了AssistedFactory修饰，该type生成ProvisionBinding对象的 provisionDependencies依赖的kind属性；

**LAZY**：Lazy< T>；

**PROVIDER_OF_LAZY**：Provider<Lazy< T>>；

**MEMBERS_INJECTION**：componentMethod返回类型不是subcomponent， 并且有且仅有一个参数，该方法生成的依赖RequestKind类型；

**PRODUCER**：Producer< T>；

**PRODUCED**：Produced< T>；

**FUTURE**：使用ListenableFuture< T>，只有在componentMethod方法所在 component节点是production类型才可以使用该ListenableFuture< T>返回类型；

----- **插播 RequestKind类型说明 end** ---------------

**根据依赖的key的type请求RequestKind类型判断：**

1. RequestKind.INSTANCE:BindingKind.MEMBERS_INJECTION（生成的MembersInjectionBinding对象）、BindingKind.COMPONENT_PRODUCTIONcomponent节点是production的 componentAnnotation#dependencies里面的节点的无参返回类型不是void的方法生成 ProductionBinding）、BindingKind.PRODUCTION（Produces修饰的方法）报错，其他绑定类型如下：

 - （1）如果匹配到的绑定对象的BindingKind绑定类型是ASSISTED_INJECTION：表示AssistedInject修饰的构造函数生成的绑定对象。定位到AssistedPrivateMethodRequestRepresentation对象：

 - ① 先调用SimpleMethodRequestRepresentation类的getDependencyExpression方法：生成一个调用方法的代码块，e.g.:`SourceFileGeneratorsModule_FactoryGeneratorFactory.factoryGenerator(factoryGenerator(), bindCompilerOptionsProvider.get())；`并且该方法涉及的参数有该绑定对象的依赖再去完成匹配工作；
 
 - ②对当前依赖的可以生成一个private修饰的方法，并且`生成的方法名(@Assisted修饰的参数)`；


 - （2）如果当前绑定类型不是ASSISTED_FACTORY（@AssitedFactory修饰的节点） && 没有使用Scope注解（@Binds修饰的bindingMethod如果使用了@Scope，那么它依赖匹配到的绑定对象使用了非Reusable的Scope注解也算满足条件）：

 - ① BindingKind.DELEGATE：Binds修饰的bindingMethod方法生成的绑定对象；定位到DelegateRequestRepresentation对象，传递RequestKind.INSTANCE参数，当前绑定对象的依赖的key和RequestKind.INSTANCE再去做匹配工作；

 - ② BindingKind.COMPONENT：component节点生成一个ProvisionBinding绑定对象，定位到ComponentInstanceRequestRepresentation对象，

 - ③ BindingKind.COMPONENT_DEPENDENCY：componentAnnotation#dependencies()里面的dependency节点生成ProvisionBinding绑定对象

 - ④ BindingKind.COMPONENT_PROVISION：component节点不是production的 componentAnnotation#dependencies里面的类的无参返回类型不是void的方法生成的ProvisionBinding；

 - ⑤ BindingKind.SUBCOMPONENT_CREATOR：（1）component中的方法返回类型是一个subcomponent.Builder（表示的是一个Builder）  ,并且该subcomponent不在component关联的subcomponents集合中， 那么使用当前方法和该方法所在的component类生成一个ProvisionBinding对象；（2）component关联的module类的注解moduleAnnotation#subcomponents()里面的类生成的SubcomponentDeclaration，生成ProvisionBinding对象；

 - ⑥ BindingKind.MULTIBOUND_SET：（1）@Provides或@Produces或@Binds修饰的bindingMethod，该bindingMethod还是 用了@IntoMap或@IntoSet或@ElementsIntoSet；（2）@Multibinds修饰的bindingMethod方法。 该key的type是Set< T>，那么生成的Binding对象的BindingKind属性；

 - ⑦ BindingKind.MULTIBOUND_MAP：（1）@Provides或@Produces或@Binds修饰的bindingMethod，该bindingMethod还是用了@IntoMap或@IntoSet或@ElementsIntoSet；（2）@Multibinds修饰的bindingMethod方法。该key的type是Map<K,V>，那么生成的Binding对象的BindingKind属性；

 - ⑧ BindingKind.OPTIONAL：key及其变异的type类型是Optional< T>，那么把type改成T生成新的newkey如果匹配到@BindsOptionalOf修饰的bindingMethod；

 - ⑨ BindingKind.BOUND_INSTANCE：creator节点中使用BindsInstance修饰的方法（或方法参数）， 该方法或方法参数作为bindingElement，该方法的参数根据RequestKind剥离外壳作为 type生成key——生成ProvisionBinding对象

 - ⑩ BindingKind.ASSISTED_FACTORY：表示使用AssistedFactory修饰

 - BindingKind.INJECTION（表示Inject修饰的构造函数）或BindingKind.PROVISION（表示Provides修饰方法）：
 
 - （3）如果BindingKind绑定类型是MEMBERS_INJECTOR或者不满足（1）（2）条件，表示依赖的key的type类型是MembersInjector< T>，定位到DerivedFromFrameworkInstanceRequestRepresentation类
 
 - DerivedFromFrameworkInstanceRequestRepresentation类只是做了一个代码块的转换，例如T转换成`T.get()`,将匹配的绑定对象的依赖的key的type修改成RequestKind.PROVIDER继续做匹配工作；


2. RequestKind.PROVIDER:

3. RequestKind.LAZY、RequestKind.PRODUCED、RequestKind.PROVIDER_OF_LAZY： 定位到DerivedFromFrameworkInstanceRequestRepresentation类，并且将传递**FrameworkType.PROVIDER参数（为接下来的匹配类型做准备）**

 - DerivedFromFrameworkInstanceRequestRepresentation类只是做了一个代码块的转换，例如T转换成`T.get()`,将依赖的key的type修改成RequestKind.PROVIDER继续做匹配工作；

4. RequestKind.PRODUCER：定位到ProducerNodeInstanceRequestRepresentation类；

 - 添加代码块`Producers.cancel($L, mayInterruptIfRunning);`代码块，$L来源如下：

 - （1）当前被依赖匹配到的绑定对象B，调用ProducerFromProviderCreationExpression的creationExpression生成代码块`Producers.producerFromProvider($L2)`，$L2来源将当前绑定对象的key的type类型变为**RequestKind.PROVIDER**继续做匹配工作；

 - （2）将B对象的依赖的key的type生成变量，并且生成代码块`"this.变量名 = Producers.producerFromProvider($L2);`当前代码块赋值就是$L;

5. RequestKind.FUTURE：定位到ImmediateFutureRequestRepresentation类；

 - 生成代码块`Futures.immediateFuture($L)`，这里的$L将传递进来的key的type类型变成RequestKind.INSTANCE继续做匹配工作；

6. RequestKind.MEMBERS_INJECTION：会报错

#### 匹配到ProductionBinding对象 ####

**根据依赖的key的type的FrameWorkType类型判断：**

1. 没有使用FrameWorkType类型：

2. FrameworkType.PROVIDER：

3. FrameworkType.PRODUCER_NODE：