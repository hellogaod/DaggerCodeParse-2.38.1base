# 简介 #

BasicAnnotationProcessor来源


    implementation "com.google.auto:auto-common:0.10"

BasicAnnotationProcessor继承了AbstractProcessor，一个基础类注解处理器。

如果是一个简单的注解处理器，我们可以直接使用一个自定义AbstractProcessor处理对应的注解，可参考：[Android循序渐进实现高逼格自定义ViewBinder](https://blog.csdn.net/foshengtang/article/details/109577855)。但是相对来说，dagger过于复杂，首先注解种类比较多：Inject,Component,ProductComponent,Provider,BindsInstance等；其次还需要针对注解进行校验，是否符合使用规范；并且逻辑代码也比较复杂，如果仅仅使用自定义AbstractProcessor也体现不了高质量代码的必要性。

BasicAnnotationProcessor代码质量非常高，里面的代码的写法非常值得我们学习借鉴。

# 源码思路整理 #

1.在BasicAnnotationProcessor中定义了一个Step接口，该接口用于处理某一类注解。代码如下：


    public interface Step {//某一类注解集及其逻辑处理，该接口的实现者处理注解集的核心逻辑

        //存储该类注解集合
        Set<? extends Class<? extends Annotation>> annotations();

        //annotations中的注解集合的逻辑处理：注解使用规范校验，注解代码生成
        Set<? extends Element> process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation);
    }

例如定义一个`ComponentStep implements Step` 表示处理Component相关注解逻辑：1.annotations()方法存放需要处理的注解集；2.process方法处理annotations()中注解集的逻辑代码，包括：校验，生成对应的逻辑代码。

2.BasicAnnotationProcessor是一个abstract抽象类，继承AbstractProcessor必然实现了以下方法：

(1) init(ProcessingEnvironment processingEnv):一些初始化操作，获取一些有用的系统工具类，该方法只会执行一次

(2) SourceVersion getSupportedSourceVersion() ：BasicAnnotationProcessor并不知道继承者的版本，所以该方法没有实现，需要由继承者自己实现

(3) Set<String> getSupportedAnnotationTypes()：设置支持的注解类型，获取所有的Step接口annotations()方法中的注解集合，会执行多次

(4) boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment)：注解内部逻辑的实现：1.会执行多次，并且调用process前一定会执行getSupportedAnnotationTypes()方法；2.process最后一次的执行roundEnvironment.processingOver() = true（前几次都是false），表示执行完毕

3.BasicAnnotationProcessor类定义了一个steps集合：`ImmutableList<? extends Step> steps;`，它的三个方法都是围绕着steps操作：

（1）init初始化steps集合；

（2）getSupportedAnnotationTypes()注解类型，取自于steps的step.annotations()

（3）process，通过for循环，执行step.process，实际的每个step逻辑执行方法


# 源码解析 #

## 一.定义Step接口 ##

BasicAnnotationProcessor中的方法都是围绕着Step实现者操作：

    public interface Step {//某一类注解集及其逻辑处理，该接口的实现者处理注解集的核心逻辑

        //存储该类注解集合
        Set<? extends Class<? extends Annotation>> annotations();

        //annotations中的注解集合的逻辑处理：注解使用规范校验，注解代码生成
        Set<? extends Element> process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation);
    }


## 二.init(ProcessingEnvironment processingEnv)方法 ##

	 private ImmutableList<? extends Step> steps;

	//一些初始化操作，获取一些有用的系统工具类
    @Override
    public synchronized void init(ProcessingEnvironment processingEnv) {
        super.init(processingEnv);
       ...
        this.steps = ImmutableList.copyOf(initSteps());
    }

    protected Iterable<? extends Step> initSteps() {
        throw new AssertionError("If steps() is not implemented, initSteps() must be.");
    }

如上，steps集合来源于initSteps()方法，这个是一个典型的模板模式（或者接口模式），继承者实现initSteps()方法，确定需要处理那些<? extends> ，例如：

	@AutoService(Processor.class)
	public class TestBasicAnnotationProcessor extends BasicAnnotationProcessor {
	
	    @Override
	    public SourceVersion getSupportedSourceVersion() {
	        return SourceVersion.latestSupported();
	    }
	
	    @Override
	    protected Iterable<? extends Step> initSteps() {
	        Messager messager = processingEnv.getMessager();
	
	        messager.printMessage(Diagnostic.Kind.NOTE, "BasicAnnotationProcessor初始化step步骤");
	
	        return ImmutableList.of(new InjectStep(messager), new ComponentStep(messager));
	    }
	}

处理InjectStep和ComponentStep两个注解Step

InjectStep包含TestInject注解：

	public class InjectStep implements BasicAnnotationProcessor.Step {
	    private final Messager messager;
	
	    public InjectStep(Messager messager) {
	        this.messager = messager;
	    }
	
	    //表示TestInject注解都是在该step中处理
	    @Override
	    public Set<? extends Class<? extends Annotation>> annotations() {
	        messager.printMessage(Diagnostic.Kind.NOTE, "TestInject注解");
	
	        return ImmutableSet.of(TestInject.class);
	    }
	
	    //表示TestInject注解都是在该step中处理逻辑代码
	    @Override
	    public Set<? extends Element> process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
	
	        messager.printMessage(Diagnostic.Kind.NOTE, "TestInject注解逻辑");
	
	        return ImmutableSet.of();
	    }
	}

ComponentStep包含：TestComponent和TestProductComponent两个注解

	public class ComponentStep implements BasicAnnotationProcessor.Step {
	    private final Messager messager;
	
	    public ComponentStep(Messager messager) {
	        this.messager = messager;
	    }
	
	    //表示TestComponent和TestProductComponent两个注解都是在该step中处理
	    @Override
	    public Set<? extends Class<? extends Annotation>> annotations() {
	        messager.printMessage(Diagnostic.Kind.NOTE, "TestComponent TestProductComponent注解");
	        return ImmutableSet.of(TestComponent.class, TestProductComponent.class);
	    }
	
	    //表示TestComponent和TestProductComponent两个注解都是在该step中处理相关逻辑代码
	    @Override
	    public Set<? extends Element> process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
	
	        messager.printMessage(Diagnostic.Kind.NOTE, "TestComponent TestProductComponent注解逻辑");
	
	        return ImmutableSet.of();
	    }
	}

针对不同注解集的处理都是在process方法中

三.getSupportedAnnotationTypes所有的注解类型，在steps集合的Step.annotation中找

	//设置支持的注解类型
    @Override
    public ImmutableSet<String> getSupportedAnnotationTypes() {

        Preconditions.checkState(steps != null);

        //stream汇集steps集合中的step注解归类中的注解集合
        return steps.stream() //stream 创建流
                .flatMap(step -> step.annotations().stream())// flatMap执行过滤
                .map(annotation -> ((Class) annotation).getCanonicalName())//map将流中的元素映射成另外的值
                .collect(Collectors.collectingAndThen(Collectors.toList(), ImmutableSet::copyOf));
    }


四.process注解处理

（一）.定义了两个延时集合


1.因为process会被执行多次，可能存在延时（未处理）节点，用于存储未处理节点，方便再次调用process进行处理

	private final Set<ElementName> deferredElementNames = new LinkedHashSet<>();

2.针对Step.process方法有一个返回类型： Set<? extends Element> ，process处理过程中，针对没有被处理（处理异常节点）都会存储于elementsDeferredBySteps集合中，在处理完成后会打印出错误信息
	
	private final SetMultimap<Step, ElementName> elementsDeferredBySteps = LinkedHashMultimap.create();

（二）.roundEnv.processingOver()方法:表示注解处理完成调用，process方法会被调用多次，只有在最后一次调用roundEnv.processingOver() = true。

处理完成，如果deferredElementNames（未被处理节点），elementsDeferredBySteps（所有<? extends Step>中异常节点）存在，那么打印出异常节点信息

	if (roundEnv.processingOver()) {
            postRound(roundEnv);

            //表示roundEnv环境处理过程中没有出现错误:Diagnostic.Kind.ERROR
            if (!roundEnv.errorRaised()) {

                //把错误通过messager打印
                reportMissingElements(
                        ImmutableSet.<ElementName>builder()
                                .addAll(deferredElementNames)
                                .addAll(elementsDeferredBySteps.values()).build()
                );
            }

            return false;
        }

（三）. validElements：有效节点

1.getAllStepSupportedAnnotationTypeElements方法获取steps集合所有注解，代码如下：

	private ImmutableSet<TypeElement> getAllStepSupportedAnnotationTypeElements() {

        Preconditions.checkState(steps != null);

        return steps.stream()
                .flatMap(step -> getStepSupportedAnnotationTypeElements(step).stream())
                .collect(Collectors.collectingAndThen(Collectors.toList(), ImmutableSet::copyOf));
    }

 steps.stream().flatMap实现转换调用getStepSupportedAnnotationTypeElements获取step中的annotation注解集：

	//获取Step中注解类对应的TypeElement
    private ImmutableSet<TypeElement> getStepSupportedAnnotationTypeElements(Step step) {
        //Step中的注解通过（注解clazz.getCanonicalName()）注解类名（不要搞错了，是注解类，而不是注解所在的类）在elements中找到对应的TypeElement
        return step.annotations().stream()
                .map(clazz -> clazz.getCanonicalName())
                .map(elements::getTypeElement)
                .filter(Objects::nonNull)
                .collect(Collectors.collectingAndThen(Collectors.toList(), ImmutableSet::copyOf));
    }

2.查找（深挖）注解节点，并且以key：注解，value：使用该注解的节点存储于ImmutableSetMultimap中

	/**
     * 深挖element节点（1.如果不是类或接口继续递归：比如方法，变量；2.如果是方法，针对参数深挖）
     * 找到element使用了annotationTypes集中注解并且存储于annotatedElements中
     * <p>
     * 存储的是集合，Key：TypeElement类型注解，value:使用TypeElement注解的Element节点
     *
     * @param element           查询的节点
     * @param annotationTypes   注解TypeElement格式的集合
     * @param annotatedElements 存放注解信息的位置？？？，坚定答：存储的是集合，Key：TypeElement类型注解，value:使用TypeElement注解的Element节点
     */
    private static void findAnnotatedElements(Element element,
                                              ImmutableSet<TypeElement> annotationTypes,
                                              ImmutableSetMultimap.Builder<TypeElement, Element> annotatedElements) {
        //getEnclosedElements：获取当前节点下的所有子节点
        for (Element encloseElement : element.getEnclosedElements()) {
            //既不是类又不是接口，传入encloseElement进行递归：比如变量，方法
            if (!encloseElement.getKind().isClass() && !encloseElement.getKind().isInterface()) {
                findAnnotatedElements(encloseElement, annotationTypes, annotatedElements);
            }
        }

        //表示一个方法节点
        if (element instanceof ExecutableElement) {
            for (Element parameterElement : MoreElements.asExecutable(element).getParameters()) {
                //方法节点，传入参数parameterElement节点继续递归
                findAnnotatedElements(parameterElement, annotationTypes, annotatedElements);
            }
        }

        //最终的目标：判断element节点上的注解集是否匹配上annotationTypes注解集，如果匹配上则存储
        //存储方式：key：annotationType(注解表示的TypeElement),value:element（节点）
        for (TypeElement annotationType : annotationTypes) {
            if (isAnnotationPresent(element, annotationType)) {

                annotatedElements.put(annotationType, element);
            }
        }
    }

    //判断Element所使用的注解集能否匹配上annotationType
    private static boolean isAnnotationPresent(Element element, TypeElement annotationType) {
        //getAnnotationMirrors返回直接存在于此元素上的注解
        return element.getAnnotationMirrors().stream()
                .anyMatch(
                        mirror -> MoreTypes.asTypeElement(mirror.getAnnotationType()).equals(annotationType)
                );
    }

3.如下代码很长，舍不得做删减，所以全部贴出来了。主要几大块：

（1）对deferredElementNames（来源：可以下面查看代码，不存在于elements中都会存储于该集合，或者节点类存在问题也会存储该集合）处理，不存在于elements中在此添加到deferredElementNames中表示再延期处理，存在于elements中，使用到`steps->step.annotations`注解集的节点，以key=注解，value=使用该注解的节点保留成map形式

（2）遍历所有`steps->step.annotations`注解集，执行for循环，核心代码：`roundEnv.getElementsAnnotatedWith(annotationType)`，获取使用到annotationType注解的节点集；在找到（1）中使用annotationType注解的节点集；二者取并集`Sets.unio(roundElements,prevRoundElements)`

 判断节点有效 = 有效节点集包含 || (未处理节点集中不包含 && 元素合法性校验)，有效存储于validElements；无效存储于deferredElementNames做延期处理


	/**
     * 筛选有效的Element集。
     * <p>
     * 两个核心的方法：
     * 1.roundEnv.getElementsAnnotatedWith(annotationType)  在RoundEnvironment找使用了annotationType的节点集
     * 2.deferredElementName.getElement(elements) 在elements（init中初始化 this.elements = processingEnv.getElementUtils()）通过name（类名或包名）获取element节点
     * <p>
     * 有效节点哪里获取：
     * 1.之前未处理（延迟）的节点集
     * 2.使用roundEnv.getElementsAnnotatedWith(annotationType)，roundEnv找使用annotationType注解的节点集
     *
     * @param roundEnv 在RoundEnvironment筛选所需要的Element集，肯定是满足使用了所有Step里面的注解的节点
     * @return
     */
    private ImmutableSetMultimap<TypeElement, Element> validElements(RoundEnvironment roundEnv) {

        //先把之前所有延期的节点拷贝并清空之前的
        ImmutableSet<ElementName> prevDeferredElementNames = ImmutableSet.copyOf(deferredElementNames);
        deferredElementNames.clear();

        //新建的集合用于存放未被处理的节点
        ImmutableSetMultimap.Builder<TypeElement, Element> deferredElementsByAnnotationBuilder = ImmutableSetMultimap.builder();

        //首先处理之前未被处理（延迟）的节点
        for (ElementName deferredElementName : prevDeferredElementNames) {

            Optional<? extends Element> deferredElement = deferredElementName.getElement(elements);

            if (deferredElement.isPresent()) {//表示节点存在于elements中
                //深挖deferredElement节点，将节点里面所有使用到getAllStepSupportedAnnotationTypeElements返回注解集的元素存储于deferredElementsByAnnotationBuilder中
                //注意它的存储是key:注解，value:使用该注解的节点
                findAnnotatedElements(deferredElement.get(),
                        getAllStepSupportedAnnotationTypeElements(), //所有注解TypeElement集合
                        deferredElementsByAnnotationBuilder);
            } else {//不存在，放在未处理（延迟）节点集合中
                deferredElementNames.add(deferredElementName);
            }
        }

        //处理完成build一下
        ImmutableSetMultimap<TypeElement, Element> deferredElementsByAnnotation = deferredElementsByAnnotationBuilder.build();

        //用于存储有效节点，key：注解，value：使用该注解的节点
        ImmutableSetMultimap.Builder<TypeElement, Element> validElements = ImmutableSetMultimap.builder();

        //有效节点
        Set<ElementName> validElementNames = new LinkedHashSet<>();

        //循环Steps集合中的所有注解，这里再次获取一次getAllStepSupportedAnnotationTypeElements，确保获取的注解集是最新的
        for (TypeElement annotationType : getAllStepSupportedAnnotationTypeElements()) {

            //getElementsAnnotatedWith:使用了annotationType注解的所有Element元素
            Set<? extends Element> roundElements = (annotationType == null) ?
                    ImmutableSet.of()
                    : roundEnv.getElementsAnnotatedWith(annotationType);

            //表示使用了annotationType注解的未被处理（延迟）的节点
            ImmutableSet<Element> prevRoundElements = deferredElementsByAnnotation.get(annotationType);

            //Sets.union去两个集合的并集
            for (Element element : Sets.union(roundElements, prevRoundElements)) {
                //根据element生成ElementName对象
                ElementName elementName = ElementName.forAnnotatatedElement(element);

                //判断节点有效 = 有效节点集包含 || (未处理节点集中不包含 && 元素合法性校验)
                boolean isValidElement = validElementNames.contains(elementName) ||
                        (
                                !deferredElementNames.contains(elementName)
                                        && SuperficialValidation.validateElement(element.getKind().equals(ElementKind.PACKAGE) ? element : getEnclosingType(element))
                        );

                if (isValidElement) {
                    validElements.put(annotationType, element);
                    validElementNames.add(elementName);
                } else {
                    deferredElementNames.add(elementName);
                }
            }
        }

        //最终生成有效节点并且返回
        return validElements.build();

    }

4.processStep调用step.process处理。如下代码，注意：

（1）.elementsDeferredBySteps存储` Set<? extends Element> rejectedElements = step.process(toClassKeyedMultimap(stepElements));`表示step.process处理异常节点集

（2）.stepElements存储了当前step使用的annotation注解的集合

	/**
     * 对step处理
     *
     * @param validElements 所有的有效节点
     */
    private void processStep(ImmutableSetMultimap<TypeElement, Element> validElements) {
        for (Step step : steps) {
            //获取当前step的注解
            ImmutableSet<TypeElement> annotationTypes = getStepSupportedAnnotationTypeElements(step);

            ImmutableSetMultimap<TypeElement, Element> stepElements =
                    new ImmutableSetMultimap.Builder<TypeElement, Element>()
                            //未处理的注解
                            .putAll(indexByAnnotation(elementsDeferredBySteps.get(step), annotationTypes))
                            //有效节点筛选自annotationTypes集
                            .putAll(Multimaps.filterKeys(validElements, Predicates.in(annotationTypes)))
                            .build();

            if (stepElements.isEmpty()) {
                elementsDeferredBySteps.removeAll(step);
            } else {

                //调用Step的process方法
                Set<? extends Element> rejectedElements = step.process(toClassKeyedMultimap(stepElements));

                elementsDeferredBySteps.replaceValues(step, Iterables.transform(rejectedElements, ElementName::forAnnotatatedElement));
            }
        }
    }

处理完成，并且没有发生ERROR错误，打印出没被处理的节点

# 知识点梳理 #